{"/home/travis/build/npmtest/node-npmtest-sql-cli/test.js":"/* istanbul instrument in package npmtest_sql_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/lib.npmtest_sql_cli.js":"/* istanbul instrument in package npmtest_sql_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sql_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sql_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sql-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sql_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sql_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sql_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sql_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sql_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sql_cli.__dirname +\n                    '/lib.npmtest_sql_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/cli.js":"(function () {\n    \"use strict\";\n\n    var _ = require('underscore'),\n        _str = require('underscore.string'),\n        Prompt = require('./prompt'),\n        MSSQLDbService = require('./mssqldb'),\n        Options = require('./options'),\n        Commands = require('./commands'),\n        ResultWriter = require('./resultwriter'),\n        Messages = require('./messages'),\n        exit = require('../external/exit');\n\n    var Invoker = Commands.Invoker,\n        Utils = Commands.Utils,\n        Buffer = Commands.Buffer,\n        Queue = Commands.Queue;\n\n    _.mixin(_str.exports());\n\n    class SqlCli {\n        constructor() {\n            this.db = new MSSQLDbService();\n            this.messages = new Messages();\n            this.options = new Options();\n            this.buffer = new Buffer();\n        }\n\n        run(argv, env, pageSize) {\n            // parse arguments\n            return this.options.init(argv, env).then(()=>\n            {                \n                this.messages.pageSize = pageSize;\n\n                // if user just wants to run query then we're not in interactive mode\n                this.messages.interactiveMode = this.options.args.query === undefined;\n                this._createWriter(this.options.args.format);\n\n                var config = this.options.getConnectionInfo();\n\n                this.messages.connecting(config.server);\n                this.db.connect(config)\n                    .then(this._onConnect.bind(this),\n                    this._onConnectError.bind(this));\n            }, err => {\n                this.messages.error(err);\n                exit(-1);                \n            });\n        }\n\n        _createWriter(format) {\n            try {\n                this.writer = ResultWriter.create(format);\n            }\n            catch (e) {\n                this._onErrorExit(e.message);\n                return;\n            }\n\n            // if output is not in a tabular format then don't write extra messages on console\n            this.messages.enabled = this.messages.interactiveMode || (this.writer instanceof ResultWriter.TableWriter);\n        }\n\n        _onConnect() {\n            this.buffer.on('command', cmd => this.queue.addCommand(cmd));\n\n            this.prompt = new Prompt();\n            this.prompt.on('line', line => this._runCommand(line, false /*thenExit*/));\n            this.prompt.on('close', ()=> this.queue.end());\n            this.prompt.on('exit', code => exit(code));\n\n            this.invoker = new Invoker(this.db, this.messages, this.writer);\n            this.invoker.commands.forEach(this.prompt.addCommand.bind(this.prompt));\n\n            this.queue = new Queue(this.invoker, this.prompt, this.messages);\n\n            if (this.options.args.query) {\n                this._runCommand(this.options.args.query, true /*thenExit*/);\n                return;\n            }\n\n            this.messages.connected();\n            this.messages.welcome(this.options.version);\n\n            this.prompt.next();\n        }\n\n        _onConnectError(err) {\n            this.messages.connectionerror(err);\n            exit(-1);\n        }\n\n        _onErrorExit(err) {\n            this.prompt.exit = true;\n            this._onErrorNext(err);\n        }\n\n        _onErrorNext(err) {\n            if (err) {\n                this.messages.error(err);\n                this.prompt.next(-1);\n            }\n        }\n\n        _runCommand(line, thenExit) {\n            this.prompt.exit = thenExit;\n\n            // if there is nothing to process\n            // or the command is incomplete\n            // then prompt for more\n            if (!line || !this.buffer.addLine(line)) {\n                this.prompt.next();\n            }\n        }\n    }\n\n    module.exports = exports = SqlCli;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/prompt.js":"(function () {\n    \"use strict\";\n\n    var _str = require('underscore.string'),\n        readline = require('readline'),\n        config = require('./prompt.json');\n\n    const EventEmitter = require('events');\n\n    class Prompt extends EventEmitter {        \n\n        constructor() {\n            super();\n\n            this.commands = [];\n            // initialize prompt\n            this.rl = readline.createInterface({ \n                input: process.stdin, \n                output: process.stdout,\n                completer: this._completer.bind(this)\n            });\n            this.rl.setPrompt(config.prompt);\n            this.rl.on('line', line=>this.emit('line', line));\n            this.rl.on('close', ()=>this.emit('close'));\n        }\n\n        addCommand(command) {\n            this.commands.push(command);\n        }\n\n        next(code) {\n            if (this.exit) {\n                code = code === undefined ? 0 : code;\n                this.emit('exit', code);\n            }\n            else {\n                setImmediate(this.rl.prompt.bind(this.rl));\n            }\n        }\n\n        _completer(line) {\n            var result = this._matchCommands(line);\n            if (result[0].length === 0) {\n                result = this._matchKeywords(line);\n            }\n            return result;               \n        }\n\n        _matchCommands(line) {\n            var hits = this.commands.filter(c => _str.startsWith(c.prefix, line)).map(c => c.prefix);\n\n            return [hits.length ? hits : [], line];\n        }\n\n        _matchKeywords(line) {\n            var lastWord = line.substring(line.lastIndexOf(' ') + 1);\n            if (!lastWord) return [[],lastWord];\n\n            var wordCase = lastWord.charAt(lastWord.length - 1);\n            var caseFix = wordCase === wordCase.toUpperCase() ? String.prototype.toUpperCase : String.prototype.toLowerCase; \n            \n            var regex = new RegExp(\"^\" + lastWord, \"i\");\n            var hits = config.keywords\n                            .filter(c => regex.test(c))\n                            .map(x => caseFix.call(x));\n            \n            return [hits.length ? hits : [], lastWord];\n        }\n    }\n\n    module.exports = exports = Prompt;\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/mssqldb.js":"(function () {\n    \"use strict\";\n\n    var _ = require('underscore'),\n        Q = require('q'),\n        _str = require('underscore.string'),\n        mssql = require('mssql');\n\n    class MSSQLDbService {\n\n        constructor() {\n        }\n\n        connect(config) {\n            this.connection = new mssql.Connection(config);\n            return this.connection.connect();\n        }\n\n        query(sql) {\n            var request = new mssql.Request(this.connection);\n            request.stream = true;\n            request.multiple = true;\n\n            sql = _str.trim(sql);\n            request.batch(sql);\n\n            return request;\n        }\n\n    }\n\n    module.exports = exports = MSSQLDbService;\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/index.js":"module.exports = require(\"./lib/main\")","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/lib/main.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var Connection, ConnectionError, ConnectionString, DRIVERS, EventEmitter, ISOLATION_LEVEL, PreparedStatement, PreparedStatementError, Request, RequestError, TYPES, Table, Transaction, TransactionError, declare, fs, getTypeByValue, global_connection, key, map, ref, ref1, util, value,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  EventEmitter = require('events').EventEmitter;\n\n  util = require('util');\n\n  fs = require('fs');\n\n  ref = require('./datatypes'), TYPES = ref.TYPES, declare = ref.declare;\n\n  ISOLATION_LEVEL = require('./isolationlevel');\n\n  DRIVERS = ['msnodesql', 'tedious', 'tds', 'msnodesqlv8'];\n\n  Table = require('./table');\n\n  ConnectionString = require('./connectionstring');\n\n  global_connection = null;\n\n  map = [];\n\n\n  /*\n  Register you own type map.\n  \n  **Example:**\n  ```\n  sql.map.register(MyClass, sql.Text);\n  ```\n  You can also overwrite default type map.\n  ```\n  sql.map.register(Number, sql.BigInt);\n  ```\n  \n  @path module.exports.map\n  @param {*} jstype JS data type.\n  @param {*} sqltype SQL data type.\n   */\n\n  map.register = function(jstype, sqltype) {\n    var i, index, item, len;\n    for (index = i = 0, len = this.length; i < len; index = ++i) {\n      item = this[index];\n      if (!(item.js === jstype)) {\n        continue;\n      }\n      this.splice(index, 1);\n      break;\n    }\n    this.push({\n      js: jstype,\n      sql: sqltype\n    });\n    return null;\n  };\n\n  map.register(String, TYPES.NVarChar);\n\n  map.register(Number, TYPES.Int);\n\n  map.register(Boolean, TYPES.Bit);\n\n  map.register(Date, TYPES.DateTime);\n\n  map.register(Buffer, TYPES.VarBinary);\n\n  map.register(Table, TYPES.TVP);\n\n\n  /*\n  @ignore\n   */\n\n  getTypeByValue = function(value) {\n    var i, item, j, k, l, len, len1, len2, len3;\n    if (value === null || value === void 0) {\n      return TYPES.NVarChar;\n    }\n    switch (typeof value) {\n      case 'string':\n        for (i = 0, len = map.length; i < len; i++) {\n          item = map[i];\n          if (item.js === String) {\n            return item.sql;\n          }\n        }\n        return TYPES.NVarChar;\n      case 'number':\n        for (j = 0, len1 = map.length; j < len1; j++) {\n          item = map[j];\n          if (item.js === Number) {\n            return item.sql;\n          }\n        }\n        return TYPES.Int;\n      case 'boolean':\n        for (k = 0, len2 = map.length; k < len2; k++) {\n          item = map[k];\n          if (item.js === Boolean) {\n            return item.sql;\n          }\n        }\n        return TYPES.Bit;\n      case 'object':\n        for (l = 0, len3 = map.length; l < len3; l++) {\n          item = map[l];\n          if (value instanceof item.js) {\n            return item.sql;\n          }\n        }\n        return TYPES.NVarChar;\n      default:\n        return TYPES.NVarChar;\n    }\n  };\n\n\n  /*\n  Class Connection.\n  \n  Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\n  \n  @property {Boolean} connected If true, connection is established.\n  @property {Boolean} connecting If true, connection is being established.\n  @property {*} driver Reference to configured Driver.\n  \n  @event connect Dispatched after connection has established.\n  @event close Dispatched after connection has closed a pool (by calling close).\n   */\n\n  Connection = (function(superClass) {\n    extend(Connection, superClass);\n\n    Connection.prototype.connected = false;\n\n    Connection.prototype.connecting = false;\n\n    Connection.prototype.driver = null;\n\n\n    /*\n    \tCreate new Connection.\n    \t\n    \t@param {Object|String} config Connection configuration object or connection string.\n    \t@callback [callback] A callback which is called after connection has established, or an error has occurred.\n    \t\t@param {Error} err Error on error, otherwise null.\n     */\n\n    function Connection(config1, callback) {\n      var base, base1, base2, base3, base4, err, error, ex, ref1;\n      this.config = config1;\n      if ('string' === typeof this.config) {\n        try {\n          this.config = ConnectionString.resolve(this.config);\n        } catch (error) {\n          ex = error;\n          if (callback) {\n            return callback(ex);\n          } else {\n            throw ex;\n          }\n        }\n      }\n      if ((base = this.config).driver == null) {\n        base.driver = 'tedious';\n      }\n      if ((base1 = this.config).port == null) {\n        base1.port = 1433;\n      }\n      if ((base2 = this.config).options == null) {\n        base2.options = {};\n      }\n      if ((base3 = this.config).stream == null) {\n        base3.stream = false;\n      }\n      if ((base4 = this.config).parseJSON == null) {\n        base4.parseJSON = false;\n      }\n      if (/^(.*)\\\\(.*)$/.exec(this.config.server)) {\n        this.config.server = RegExp.$1;\n        this.config.options.instanceName = RegExp.$2;\n      }\n      if (ref1 = this.config.driver, indexOf.call(DRIVERS, ref1) >= 0) {\n        this.driver = this.initializeDriver(require(\"./\" + this.config.driver));\n        if (module.exports.fix) {\n          this.driver.fix();\n        }\n      } else {\n        err = new ConnectionError(\"Unknown driver \" + this.config.driver + \"!\", 'EDRIVER');\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n      if (callback) {\n        this.connect(callback);\n      }\n    }\n\n\n    /*\n    \tWrite message to debug stream.\n     */\n\n    Connection.prototype._debug = function(msg) {\n      var ref1;\n      return (ref1 = this._debugStream) != null ? ref1.write((String(msg).replace(/\\x1B\\[[0-9;]*m/g, '')) + \"\\n\") : void 0;\n    };\n\n\n    /*\n    \tInitializes driver for this connection. Separated from constructor and used by co-mssql.\n    \t\n    \t@private\n    \t@param {Function} driver Loaded driver.\n    \t\n    \t@returns {Connection}\n     */\n\n    Connection.prototype.initializeDriver = function(driver) {\n      return driver(Connection, Transaction, Request, ConnectionError, TransactionError, RequestError);\n    };\n\n\n    /*\n    \tCreates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\n    \t\n    \t@callback [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\n    \t@returns {Connection|Promise}\n     */\n\n    Connection.prototype.connect = function(callback) {\n      if (callback != null) {\n        return this._connect(callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._connect(function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(_this);\n          });\n        };\n      })(this));\n    };\n\n    Connection.prototype._connect = function(callback) {\n      var go;\n      if (!this.driver) {\n        return callback(new ConnectionError(\"Connection was closed. Create a new instance.\"));\n      }\n      if (this.connected) {\n        return callback(new ConnectionError(\"Database is already connected! Call close before connecting to different database.\", 'EALREADYCONNECTED'));\n      }\n      if (this.connecting) {\n        return callback(new ConnectionError(\"Already connecting to database! Call close before connecting to different database.\", 'EALREADYCONNECTING'));\n      }\n      go = (function(_this) {\n        return function() {\n          _this.connecting = true;\n          return _this.driver.Connection.prototype.connect.call(_this, _this.config, function(err) {\n            if (!_this.connecting) {\n              return;\n            }\n            _this.connecting = false;\n            if (err) {\n              if (_this._debugStream) {\n                _this._debugStream.removeAllListeners();\n                _this._debugStream.end();\n                _this._debugStream = null;\n              }\n            } else {\n              _this.connected = true;\n              _this.emit('connect');\n            }\n            return callback(err);\n          });\n        };\n      })(this);\n      if (this.config.debug) {\n        this._debugStream = fs.createWriteStream(\"./mssql_debug_\" + (Date.now()) + \".log\");\n        this._debugStream.once('open', go);\n        this._debugStream.on('error', function(err) {\n          if (this.connecting || this.connected) {\n            return console.error(err.stack);\n          } else {\n            this._debugStream.removeListener('open', go);\n            return callback(new ConnectionError(\"Failed to open debug stream. \" + err.message, 'EDEBUG'));\n          }\n        });\n      } else {\n        go();\n      }\n      return this;\n    };\n\n\n    /*\n    \tClose all active connections in the pool.\n    \t\n    \t@callback [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\n    \t@returns {Connection|Promise}\n     */\n\n    Connection.prototype.close = function(callback) {\n      if (callback != null) {\n        return this._close(callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._close(function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve();\n          });\n        };\n      })(this));\n    };\n\n    Connection.prototype._close = function(callback) {\n      if (this._debugStream) {\n        this._debugStream.removeAllListeners();\n        this._debugStream.end();\n        this._debugStream = null;\n      }\n      if (this.connecting) {\n        this.connecting = false;\n        this.driver.Connection.prototype.close.call(this, (function(_this) {\n          return function(err) {\n            return callback(err);\n          };\n        })(this));\n        this.driver = null;\n      } else if (this.connected) {\n        this.connected = false;\n        this.driver.Connection.prototype.close.call(this, (function(_this) {\n          return function(err) {\n            if (!err) {\n              _this.connected = false;\n              _this.emit('close');\n            }\n            return callback(err);\n          };\n        })(this));\n        this.driver = null;\n      }\n      return this;\n    };\n\n\n    /*\n    \tReturns new request using this connection.\n    \t\n    \t@returns {Request}\n     */\n\n    Connection.prototype.request = function() {\n      return new Request(this);\n    };\n\n\n    /*\n    \tReturns new transaction using this connection.\n    \t\n    \t@returns {Transaction}\n     */\n\n    Connection.prototype.transaction = function() {\n      return new Transaction(this);\n    };\n\n\n    /*\n    \tCreates a new query using this connection from a tagged template string.\n    \t\n    \t@param {Array} strings Array of string literals.\n    \t@param {...*} keys Values.\n    \t@returns {Request}\n     */\n\n    Connection.prototype.query = function() {\n      var strings, values;\n      strings = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return new Request(this)._template('query', strings, values);\n    };\n\n\n    /*\n    \tCreates a new batch using this connection from a tagged template string.\n    \t\n    \t@param {Array} strings Array of string literals.\n    \t@param {...*} keys Values.\n    \t@returns {Request}\n     */\n\n    Connection.prototype.batch = function() {\n      var strings, values;\n      strings = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return new Request(this)._template('batch', strings, values);\n    };\n\n    return Connection;\n\n  })(EventEmitter);\n\n\n  /*\n  Class PreparedStatement.\n  \n  IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n  \n  @property {Connection} connection Reference to used connection.\n  @property {Boolean} multiple If `true`, `execute` will handle multiple recordsets.\n  @property {String} statement Prepared SQL statement.\n  @property {Request} lastRequest References instance of most recent Request created by executing a statement.\n   */\n\n  PreparedStatement = (function(superClass) {\n    extend(PreparedStatement, superClass);\n\n    PreparedStatement.prototype._pooledConnection = null;\n\n    PreparedStatement.prototype._queue = null;\n\n    PreparedStatement.prototype._working = false;\n\n    PreparedStatement.prototype._handle = 0;\n\n    PreparedStatement.prototype.connection = null;\n\n    PreparedStatement.prototype.transaction = null;\n\n    PreparedStatement.prototype.prepared = false;\n\n    PreparedStatement.prototype.statement = null;\n\n    PreparedStatement.prototype.parameters = null;\n\n    PreparedStatement.prototype.multiple = false;\n\n    PreparedStatement.prototype.stream = null;\n\n    PreparedStatement.prototype.lastRequest = null;\n\n\n    /*\n    \tCreate new Prepared Statement.\n    \t\n    \t@param {String} statement SQL statement.\n    \t@param {Connection} [connection] If ommited, global connection is used instead.\n     */\n\n    function PreparedStatement(connection) {\n      if (connection instanceof Transaction) {\n        this.transaction = connection;\n        this.connection = connection.connection;\n      } else if (connection instanceof Connection) {\n        this.connection = connection;\n      } else {\n        this.connection = global_connection;\n      }\n      this._queue = [];\n      this.parameters = {};\n    }\n\n\n    /*\n    \tAdd an input parameter to the prepared statement.\n    \t\n    \t**Example:**\n    \t```\n    \tstatement.input('input_parameter', sql.Int);\n    \tstatement.input('input_parameter', sql.VarChar(50));\n    \t```\n    \t\n    \t@param {String} name Name of the input parameter without @ char.\n    \t@param {*} type SQL data type of input parameter.\n    \t@returns {PreparedStatement}\n     */\n\n    PreparedStatement.prototype.input = function(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\" + name + \"'\", 'EINJECT');\n      }\n      if (arguments.length < 2) {\n        throw new PreparedStatementError(\"Invalid number of arguments. 2 arguments expected.\", 'EARGS');\n      }\n      if (type instanceof Function) {\n        type = type();\n      }\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    };\n\n\n    /*\n    \tAdd an output parameter to the prepared statement.\n    \t\n    \t**Example:**\n    \t```\n    \tstatement.output('output_parameter', sql.Int);\n    \tstatement.output('output_parameter', sql.VarChar(50));\n    \t```\n    \t\n    \t@param {String} name Name of the output parameter without @ char.\n    \t@param {*} type SQL data type of output parameter.\n    \t@returns {PreparedStatement}\n     */\n\n    PreparedStatement.prototype.output = function(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\" + name + \"'\", 'EINJECT');\n      }\n      if (arguments.length < 2) {\n        throw new PreparedStatementError(\"Invalid number of arguments. 2 arguments expected.\", 'EARGS');\n      }\n      if (type instanceof Function) {\n        type = type();\n      }\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    };\n\n\n    /*\n    \tPrepare a statement.\n    \t\n    \t@property {String} [statement] SQL statement to prepare.\n    \t@callback [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {PreparedStatement|Promise}\n     */\n\n    PreparedStatement.prototype.prepare = function(statement, callback) {\n      if (callback != null) {\n        return this._prepare(statement, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._prepare(statement, function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(_this);\n          });\n        };\n      })(this));\n    };\n\n    PreparedStatement.prototype._prepare = function(statement, callback) {\n      var done;\n      if (this._pooledConnection) {\n        callback(new PreparedStatementError(\"Statement is already prepared.\", 'EALREADYPREPARED'));\n        return this;\n      }\n      if (typeof statement === 'function') {\n        callback = statement;\n        statement = void 0;\n      }\n      if (statement != null) {\n        this.statement = statement;\n      }\n      done = (function(_this) {\n        return function(err, connection) {\n          var name, param, req;\n          if (err) {\n            return callback(err);\n          }\n          _this._pooledConnection = connection;\n          req = new Request(_this);\n          req.stream = false;\n          req.output('handle', TYPES.Int);\n          req.input('params', TYPES.NVarChar, ((function() {\n            var ref1, results;\n            ref1 = this.parameters;\n            results = [];\n            for (name in ref1) {\n              param = ref1[name];\n              results.push(\"@\" + name + \" \" + (declare(param.type, param)) + (param.io === 2 ? \" output\" : \"\"));\n            }\n            return results;\n          }).call(_this)).join(','));\n          req.input('stmt', TYPES.NVarChar, _this.statement);\n          return req.execute('sp_prepare', function(err) {\n            if (err) {\n              if (_this.transaction) {\n                _this.transaction.next();\n              } else {\n                _this.connection.pool.release(_this._pooledConnection);\n                _this._pooledConnection = null;\n              }\n              return callback(err);\n            }\n            _this._handle = req.parameters.handle.value;\n            return callback(null);\n          });\n        };\n      })(this);\n      if (this.transaction) {\n        if (!this.transaction._pooledConnection) {\n          callback(new TransactionError(\"Transaction has not begun. Call begin() first.\", 'ENOTBEGUN'));\n          return this;\n        }\n        this.transaction.queue(done);\n      } else {\n        this.connection.pool.acquire(done);\n      }\n      return this;\n    };\n\n\n    /*\n    \tExecute next request in queue.\n    \t\n    \t@private\n    \t@returns {PreparedStatement}\n     */\n\n    PreparedStatement.prototype.next = function() {\n      if (this._queue.length) {\n        process.nextTick((function(_this) {\n          return function() {\n            return _this._queue.shift()(null, _this._pooledConnection);\n          };\n        })(this));\n      } else {\n        this._working = false;\n      }\n      return this;\n    };\n\n\n    /*\n    \tAdd request to queue for connection. If queue is empty, execute the request immediately.\n    \t\n    \t@private\n    \t@callback callback A callback to call when connection in ready to execute request.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\t@param {*} conn Internal driver's connection.\n    \t@returns {PreparedStatement}\n     */\n\n    PreparedStatement.prototype.queue = function(callback) {\n      if (!this._pooledConnection) {\n        callback(new PreparedStatementError(\"Statement is not prepared. Call prepare() first.\", 'ENOTPREPARED'));\n        return this;\n      }\n      if (this._working) {\n        this._queue.push(callback);\n      } else {\n        this._working = true;\n        callback(null, this._pooledConnection);\n      }\n      return this;\n    };\n\n\n    /*\n    \tExecute a prepared statement.\n    \t\n    \t@property {String} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n    \t@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {Request|Promise}\n     */\n\n    PreparedStatement.prototype.execute = function(values, callback) {\n      if (callback != null) {\n        return this._execute(values, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._execute(values, function(err, recordset) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(recordset);\n          });\n        };\n      })(this));\n    };\n\n    PreparedStatement.prototype._execute = function(values, callback) {\n      var name, param, ref1, req;\n      req = this.lastRequest = new Request(this);\n      if (this.stream != null) {\n        req.stream = this.stream;\n      }\n      req.input('handle', TYPES.Int, this._handle);\n      ref1 = this.parameters;\n      for (name in ref1) {\n        param = ref1[name];\n        req.parameters[name] = {\n          name: name,\n          type: param.type,\n          io: param.io,\n          value: values[name],\n          length: param.length,\n          scale: param.scale,\n          precision: param.precision\n        };\n      }\n      req.execute('sp_execute', (function(_this) {\n        return function(err, recordsets, returnValue) {\n          if (err) {\n            return callback(err);\n          }\n          return callback(null, (_this.multiple ? recordsets : recordsets[0]), req.rowsAffected);\n        };\n      })(this));\n      return req;\n    };\n\n\n    /*\n    \tUnprepare a prepared statement.\n    \t\n    \t@callback [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {PreparedStatement|Promise}\n     */\n\n    PreparedStatement.prototype.unprepare = function(callback) {\n      if (callback != null) {\n        return this._unprepare(callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._unprepare(function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve();\n          });\n        };\n      })(this));\n    };\n\n    PreparedStatement.prototype._unprepare = function(callback) {\n      var done, req;\n      if (!this._pooledConnection) {\n        callback(new PreparedStatementError(\"Statement is not prepared. Call prepare() first.\", 'ENOTPREPARED'));\n        return this;\n      }\n      done = (function(_this) {\n        return function(err) {\n          if (err) {\n            return callback(err);\n          }\n          if (_this.transaction) {\n            _this.transaction.next();\n          } else {\n            _this.connection.pool.release(_this._pooledConnection);\n            _this._pooledConnection = null;\n          }\n          _this._handle = 0;\n          return callback(null);\n        };\n      })(this);\n      req = new Request(this);\n      req.stream = false;\n      req.input('handle', TYPES.Int, this._handle);\n      req.execute('sp_unprepare', done);\n      return this;\n    };\n\n    return PreparedStatement;\n\n  })(EventEmitter);\n\n\n  /*\n  Class Transaction.\n  \n  @property {Connection} connection Reference to used connection.\n  @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.\n  @property {String} name Transaction name. Empty string by default.\n  \n  @event begin Dispatched when transaction begin.\n  @event commit Dispatched on successful commit.\n  @event rollback Dispatched on successful rollback.\n   */\n\n  Transaction = (function(superClass) {\n    extend(Transaction, superClass);\n\n    Transaction.prototype._pooledConnection = null;\n\n    Transaction.prototype._queue = null;\n\n    Transaction.prototype._aborted = false;\n\n    Transaction.prototype._working = false;\n\n    Transaction.prototype.name = \"\";\n\n    Transaction.prototype.connection = null;\n\n    Transaction.prototype.isolationLevel = ISOLATION_LEVEL.READ_COMMITTED;\n\n\n    /*\n    \tCreate new Transaction.\n    \t\n    \t@param {Connection} [connection] If ommited, global connection is used instead.\n     */\n\n    function Transaction(connection) {\n      this._abort = bind(this._abort, this);\n      this.connection = connection != null ? connection : global_connection;\n      this._queue = [];\n    }\n\n\n    /*\n    \t@private\n     */\n\n    Transaction.prototype._abort = function() {\n      return this.connection.driver.Transaction.prototype._abort.call(this);\n    };\n\n\n    /*\n    \tBegin a transaction.\n    \t\n    \t@param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.\n    \t@callback [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {Transaction|Promise}\n     */\n\n    Transaction.prototype.begin = function(isolationLevel, callback) {\n      if (isolationLevel instanceof Function) {\n        callback = isolationLevel;\n        isolationLevel = void 0;\n      }\n      if (callback != null) {\n        return this._begin(isolationLevel, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._begin(isolationLevel, function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(_this);\n          });\n        };\n      })(this));\n    };\n\n    Transaction.prototype._begin = function(isolationLevel, callback) {\n      if (isolationLevel != null) {\n        this.isolationLevel = isolationLevel;\n      }\n      if (this._pooledConnection) {\n        callback(new TransactionError(\"Transaction has already begun.\", 'EALREADYBEGUN'));\n        return this;\n      }\n      this.connection.driver.Transaction.prototype.begin.call(this, (function(_this) {\n        return function(err) {\n          if (!err) {\n            _this.emit('begin');\n          }\n          return callback(err);\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tCommit a transaction.\n    \t\n    \t@callback [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {Transaction|Promise}\n     */\n\n    Transaction.prototype.commit = function(callback) {\n      if (callback != null) {\n        return this._commit(callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._commit(function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve();\n          });\n        };\n      })(this));\n    };\n\n    Transaction.prototype._commit = function(callback) {\n      if (!this._pooledConnection) {\n        callback(new TransactionError(\"Transaction has not begun. Call begin() first.\", 'ENOTBEGUN'));\n        return this;\n      }\n      if (this._working) {\n        callback(new TransactionError(\"Can't commit transaction. There is a request in progress.\", 'EREQINPROG'));\n        return this;\n      }\n      if (this._queue.length) {\n        callback(new TransactionError(\"Can't commit transaction. There are request in queue.\", 'EREQINPROG'));\n        return this;\n      }\n      this.connection.driver.Transaction.prototype.commit.call(this, (function(_this) {\n        return function(err) {\n          if (!err) {\n            _this.emit('commit');\n          }\n          return callback(err);\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tExecute next request in queue.\n    \t\n    \t@private\n    \t@returns {Transaction}\n     */\n\n    Transaction.prototype.next = function() {\n      var toAbort;\n      if (this._aborted) {\n        toAbort = this._queue;\n        this._queue = [];\n        process.nextTick((function(_this) {\n          return function() {\n            var results;\n            results = [];\n            while (toAbort.length) {\n              results.push(toAbort.shift()(new TransactionError(\"Transaction aborted.\", \"EABORT\")));\n            }\n            return results;\n          };\n        })(this));\n      }\n      this._working = false;\n      if (this._queue.length) {\n        process.nextTick((function(_this) {\n          return function() {\n            if (_this._aborted) {\n              return _this.next();\n            }\n            _this._working = true;\n            return _this._queue.shift()(null, _this._pooledConnection);\n          };\n        })(this));\n      }\n      return this;\n    };\n\n\n    /*\n    \tAdd request to queue for connection. If queue is empty, execute the request immediately.\n    \t\n    \t@private\n    \t@callback callback A callback to call when connection in ready to execute request.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\t@param {*} conn Internal driver's connection.\n    \t@returns {Transaction}\n     */\n\n    Transaction.prototype.queue = function(callback) {\n      if (!this._pooledConnection) {\n        callback(new TransactionError(\"Transaction has not begun. Call begin() first.\", 'ENOTBEGUN'));\n        return this;\n      }\n      if (this._working || this._queue.length) {\n        this._queue.push(callback);\n      } else {\n        this._working = true;\n        callback(null, this._pooledConnection);\n      }\n      return this;\n    };\n\n\n    /*\n    \tReturns new request using this transaction.\n    \t\n    \t@returns {Request}\n     */\n\n    Transaction.prototype.request = function() {\n      return new Request(this);\n    };\n\n\n    /*\n    \tRollback a transaction.\n    \t\n    \t@callback [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t@returns {Transaction|Promise}\n     */\n\n    Transaction.prototype.rollback = function(callback) {\n      if (callback != null) {\n        return this._rollback(callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._rollback(function(err) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve();\n          });\n        };\n      })(this));\n    };\n\n    Transaction.prototype._rollback = function(callback) {\n      if (this._aborted) {\n        callback(new TransactionError(\"Transaction has been aborted.\", 'EABORT'));\n        return this;\n      }\n      if (!this._pooledConnection) {\n        callback(new TransactionError(\"Transaction has not begun. Call begin() first.\", 'ENOTBEGUN'));\n        return this;\n      }\n      if (this._working) {\n        callback(new TransactionError(\"Can't rollback transaction. There is a request in progress.\", 'EREQINPROG'));\n        return this;\n      }\n      if (this._queue.length) {\n        this._aborted = true;\n      }\n      this.connection.driver.Transaction.prototype.rollback.call(this, (function(_this) {\n        return function(err) {\n          if (!err) {\n            _this.emit('rollback', _this._aborted);\n          }\n          return callback(err);\n        };\n      })(this));\n      return this;\n    };\n\n    return Transaction;\n\n  })(EventEmitter);\n\n\n  /*\n  Class Request.\n  \n  @property {Connection} connection Reference to used connection.\n  @property {Transaction} transaction Reference to transaction when request was created in transaction.\n  @property {*} parameters Collection of input and output parameters.\n  @property {Boolean} verbose If `true`, debug messages are printed to message log.\n  @property {Boolean} multiple If `true`, `query` will handle multiple recordsets (`execute` always expect multiple recordsets).\n  @property {Boolean} canceled `true` if request was canceled.\n  \n  @event recordset Dispatched when metadata for new recordset are parsed.\n  @event row Dispatched when new row is parsed.\n  @event done Dispatched when request is complete.\n  @event error Dispatched on error.\n   */\n\n  Request = (function(superClass) {\n    extend(Request, superClass);\n\n    Request.prototype.connection = null;\n\n    Request.prototype.transaction = null;\n\n    Request.prototype.pstatement = null;\n\n    Request.prototype.parameters = null;\n\n    Request.prototype.verbose = false;\n\n    Request.prototype.multiple = false;\n\n    Request.prototype.canceled = false;\n\n    Request.prototype.stream = null;\n\n    Request.prototype.rowsAffected = null;\n\n\n    /*\n    \tCreate new Request.\n    \t\n    \t@param {Connection|Transaction} connection If ommited, global connection is used instead.\n     */\n\n    function Request(connection) {\n      if (connection instanceof Transaction) {\n        this.transaction = connection;\n        this.connection = connection.connection;\n      } else if (connection instanceof PreparedStatement) {\n        this.pstatement = connection;\n        this.connection = connection.connection;\n      } else if (connection instanceof Connection) {\n        this.connection = connection;\n      } else {\n        this.connection = global_connection;\n      }\n      this.parameters = {};\n    }\n\n\n    /*\n    \tLog to a function if assigned. Else, use console.log.\n     */\n\n    Request.prototype._log = function(out) {\n      if (typeof this.logger === \"function\") {\n        return this.logger(out);\n      } else {\n        return console.log(out);\n      }\n    };\n\n\n    /*\n    \tFetch request from tagged template string.\n     */\n\n    Request.prototype._template = function(method, strings, values) {\n      var command, i, index, len, value;\n      command = [strings[0]];\n      for (index = i = 0, len = values.length; i < len; index = ++i) {\n        value = values[index];\n        this.input(\"param\" + (index + 1), value);\n        command.push(\"@param\" + (index + 1), strings[index + 1]);\n      }\n      return this[method](command.join(''));\n    };\n\n\n    /*\n    \tAcquire connection for this request from connection.\n     */\n\n    Request.prototype._acquire = function(callback) {\n      if (this.transaction) {\n        return this.transaction.queue(callback);\n      } else if (this.pstatement) {\n        return this.pstatement.queue(callback);\n      } else {\n        if (!this.connection.pool) {\n          return callback(new ConnectionError(\"Connection not yet open.\", 'ENOTOPEN'));\n        }\n        return this.connection.pool.acquire(callback);\n      }\n    };\n\n\n    /*\n    \tMakes the request dedicated to one connection.\n     */\n\n    Request.prototype._dedicated = function(connection) {\n      this._acquire = function(callback) {\n        return callback(null, connection);\n      };\n      this._release = function() {};\n      return this;\n    };\n\n\n    /*\n    \tRelease connection used by this request.\n     */\n\n    Request.prototype._release = function(connection) {\n      if (this.transaction) {\n        return this.transaction.next();\n      } else if (this.pstatement) {\n        return this.pstatement.next();\n      } else {\n        return this.connection.pool.release(connection);\n      }\n    };\n\n\n    /*\n    \tAdd an input parameter to the request.\n    \t\n    \t**Example:**\n    \t```\n    \trequest.input('input_parameter', value);\n    \trequest.input('input_parameter', sql.Int, value);\n    \t```\n    \t\n    \t@param {String} name Name of the input parameter without @ char.\n    \t@param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n    \t@param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n    \t@returns {Request}\n     */\n\n    Request.prototype.input = function(name, type, value) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\" + name + \"'\", 'EINJECT');\n      }\n      if (arguments.length === 1) {\n        throw new RequestError(\"Invalid number of arguments. At least 2 arguments expected.\", 'EARGS');\n      } else if (arguments.length === 2) {\n        value = type;\n        type = getTypeByValue(value);\n      }\n      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {\n        value = value.valueOf();\n      }\n      if (value === void 0) {\n        value = null;\n      }\n      if (value !== value) {\n        value = null;\n      }\n      if (type instanceof Function) {\n        type = type();\n      }\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    };\n\n\n    /*\n    \tAdd an output parameter to the request.\n    \t\n    \t**Example:**\n    \t```\n    \trequest.output('output_parameter', sql.Int);\n    \trequest.output('output_parameter', sql.VarChar(50), 'abc');\n    \t```\n    \t\n    \t@param {String} name Name of the output parameter without @ char.\n    \t@param {*} type SQL data type of output parameter.\n    \t@param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n    \t@returns {Request}\n     */\n\n    Request.prototype.output = function(name, type, value) {\n      if (!type) {\n        type = TYPES.NVarChar;\n      }\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\" + name + \"'\", 'EINJECT');\n      }\n      if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {\n        throw new RequestError(\"Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.\", 'EDEPRECATED');\n      }\n      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {\n        value = value.valueOf();\n      }\n      if (value === void 0) {\n        value = null;\n      }\n      if (value !== value) {\n        value = null;\n      }\n      if (type instanceof Function) {\n        type = type();\n      }\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    };\n\n\n    /*\n    \tExecute the SQL batch.\n    \n    \t@param {String} batch T-SQL batch to be executed.\n    \t@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\t@param {*} recordset Recordset.\n    \t\n    \t@returns {Request|Promise}\n     */\n\n    Request.prototype.batch = function(batch, callback) {\n      var ref1;\n      if (this.stream == null) {\n        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;\n      }\n      this.rowsAffected = 0;\n      if (this.stream || (callback != null)) {\n        return this._batch(batch, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._batch(batch, function(err, recordset) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(recordset);\n          });\n        };\n      })(this));\n    };\n\n    Request.prototype._batch = function(batch, callback) {\n      if (!this.connection) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new RequestError(\"No connection is specified for that request.\", 'ENOCONN');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      if (!this.connection.connected) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new ConnectionError(\"Connection is closed.\", 'ECONNCLOSED');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      this.canceled = false;\n      this.connection.driver.Request.prototype.batch.call(this, batch, (function(_this) {\n        return function(err, recordsets) {\n          if (_this.stream) {\n            if (err) {\n              _this.emit('error', err);\n            }\n            return _this.emit('done', _this.rowsAffected);\n          } else {\n            return callback(err, recordsets, _this.rowsAffected);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tBulk load.\n    \n    \t@param {Table} table SQL table.\n    \t@callback [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\n    \t@returns {Request|Promise}\n     */\n\n    Request.prototype.bulk = function(table, callback) {\n      var ref1;\n      if (this.stream == null) {\n        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;\n      }\n      if (this.stream || (callback != null)) {\n        return this._bulk(table, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._bulk(table, function(err, rowCount) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(rowCount);\n          });\n        };\n      })(this));\n    };\n\n    Request.prototype._bulk = function(table, callback) {\n      if (!this.connection) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new RequestError(\"No connection is specified for that request.\", 'ENOCONN');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      if (!this.connection.connected) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new ConnectionError(\"Connection is closed.\", 'ECONNCLOSED');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      this.canceled = false;\n      this.connection.driver.Request.prototype.bulk.call(this, table, (function(_this) {\n        return function(err, rowCount) {\n          if (_this.stream) {\n            if (err) {\n              _this.emit('error', err);\n            }\n            return _this.emit('done');\n          } else {\n            return callback(err, rowCount);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n    \t\n    \t@param {Stream} stream Stream to pipe data into.\n    \t@returns {Stream}\n     */\n\n    Request.prototype.pipe = function(stream) {\n      this.stream = true;\n      this.on('row', stream.write.bind(stream));\n      this.on('error', stream.emit.bind(stream, 'error'));\n      this.on('done', function() {\n        return setImmediate(function() {\n          return stream.end();\n        });\n      });\n      stream.emit('pipe', this);\n      return stream;\n    };\n\n\n    /*\n    \tExecute the SQL command.\n    \t\n    \t**Example:**\n    \t```\n    \tvar request = new sql.Request();\n    \trequest.query('select 1 as number', function(err, recordset) {\n    \t    console.log(recordset[0].number); // return 1\n    \t\n    \t    // ...\n    \t});\n    \t```\n    \t\n    \tYou can enable multiple recordsets in querries by `request.multiple = true` command.\n    \t\n    \t```\n    \tvar request = new sql.Request();\n    \trequest.multiple = true;\n    \t\n    \trequest.query('select 1 as number; select 2 as number', function(err, recordsets) {\n    \t    console.log(recordsets[0][0].number); // return 1\n    \t    console.log(recordsets[1][0].number); // return 2\n    \t\n    \t    // ...\n    \t});\n    \t```\n    \t\n    \t@param {String} command T-SQL command to be executed.\n    \t@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\t@param {*} recordset Recordset.\n    \t\n    \t@returns {Request|Promise}\n     */\n\n    Request.prototype.query = function(command, callback) {\n      var ref1;\n      if (this.stream == null) {\n        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;\n      }\n      this.rowsAffected = 0;\n      if (this.stream || (callback != null)) {\n        return this._query(command, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._query(command, function(err, recordsets) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(recordsets);\n          });\n        };\n      })(this));\n    };\n\n    Request.prototype._query = function(command, callback) {\n      if (!this.connection) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new RequestError(\"No connection is specified for that request.\", 'ENOCONN');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      if (!this.connection.connected) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new ConnectionError(\"Connection is closed.\", 'ECONNCLOSED');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      this.canceled = false;\n      this.connection.driver.Request.prototype.query.call(this, command, (function(_this) {\n        return function(err, recordsets) {\n          if (_this.stream) {\n            if (err) {\n              _this.emit('error', err);\n            }\n            return _this.emit('done', _this.rowsAffected);\n          } else {\n            return callback(err, recordsets, _this.rowsAffected);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tCall a stored procedure.\n    \t\n    \t**Example:**\n    \t```\n    \tvar request = new sql.Request();\n    \trequest.input('input_parameter', sql.Int, value);\n    \trequest.output('output_parameter', sql.Int);\n    \trequest.execute('procedure_name', function(err, recordsets, returnValue) {\n    \t    console.log(recordsets.length); // count of recordsets returned by procedure\n    \t    console.log(recordset[0].length); // count of rows contained in first recordset\n    \t    console.log(returnValue); // procedure return value\n    \t    console.log(recordsets.returnValue); // procedure return value\n    \t\n    \t    console.log(request.parameters.output_parameter.value); // output value\n    \t\n    \t    // ...\n    \t});\n    \t```\n    \t\n    \t@param {String} procedure Name of the stored procedure to be executed.\n    \t@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n    \t\t@param {Error} err Error on error, otherwise null.\n    \t\t@param {Array} recordsets Recordsets.\n    \t\t@param {Number} returnValue Procedure return value.\n    \t\n    \t@returns {Request|Promise}\n     */\n\n    Request.prototype.execute = function(command, callback) {\n      var ref1;\n      if (this.stream == null) {\n        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;\n      }\n      this.rowsAffected = 0;\n      if (this.stream || (callback != null)) {\n        return this._execute(command, callback);\n      }\n      return new module.exports.Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this._execute(command, function(err, recordset) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(recordset);\n          });\n        };\n      })(this));\n    };\n\n    Request.prototype._execute = function(procedure, callback) {\n      if (!this.connection) {\n        return process.nextTick(function() {\n          var e;\n          e = new RequestError(\"No connection is specified for that request.\", 'ENOCONN');\n          if (this.stream) {\n            this.emit('error', e);\n            return this.emit('done');\n          } else {\n            return callback(e);\n          }\n        });\n      }\n      if (!this.connection.connected) {\n        return process.nextTick((function(_this) {\n          return function() {\n            var e;\n            e = new ConnectionError(\"Connection is closed.\", 'ECONNCLOSED');\n            if (_this.stream) {\n              _this.emit('error', e);\n              return _this.emit('done');\n            } else {\n              return callback(e);\n            }\n          };\n        })(this));\n      }\n      this.canceled = false;\n      this.connection.driver.Request.prototype.execute.call(this, procedure, (function(_this) {\n        return function(err, recordsets, returnValue) {\n          if (_this.stream) {\n            if (err) {\n              _this.emit('error', err);\n            }\n            return _this.emit('done', returnValue, _this.rowsAffected);\n          } else {\n            return callback(err, recordsets, returnValue, _this.rowsAffected);\n          }\n        };\n      })(this));\n      return this;\n    };\n\n\n    /*\n    \tCancel currently executed request.\n    \t\n    \t@returns {Request}\n     */\n\n    Request.prototype.cancel = function() {\n      this.canceled = true;\n      this.connection.driver.Request.prototype.cancel.call(this);\n      return this;\n    };\n\n    return Request;\n\n  })(EventEmitter);\n\n  ConnectionError = (function(superClass) {\n    extend(ConnectionError, superClass);\n\n    function ConnectionError(message, code) {\n      var err;\n      if (!(this instanceof ConnectionError)) {\n        if (message instanceof Error) {\n          err = new ConnectionError(message.message, message.code);\n          Object.defineProperty(err, 'originalError', {\n            value: message\n          });\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        } else {\n          err = new ConnectionError(message);\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        }\n      }\n      this.name = this.constructor.name;\n      this.message = message;\n      if (code != null) {\n        this.code = code;\n      }\n      ConnectionError.__super__.constructor.call(this);\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    return ConnectionError;\n\n  })(Error);\n\n  TransactionError = (function(superClass) {\n    extend(TransactionError, superClass);\n\n    function TransactionError(message, code) {\n      var err;\n      if (!(this instanceof TransactionError)) {\n        if (message instanceof Error) {\n          err = new TransactionError(message.message, message.code);\n          Object.defineProperty(err, 'originalError', {\n            value: message\n          });\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        } else {\n          err = new TransactionError(message);\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        }\n      }\n      this.name = this.constructor.name;\n      this.message = message;\n      if (code != null) {\n        this.code = code;\n      }\n      TransactionError.__super__.constructor.call(this);\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    return TransactionError;\n\n  })(Error);\n\n  RequestError = (function(superClass) {\n    extend(RequestError, superClass);\n\n    function RequestError(message, code) {\n      var err, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;\n      if (!(this instanceof RequestError)) {\n        if (message instanceof Error) {\n          err = new RequestError(message.message, (ref1 = message.code) != null ? ref1 : code);\n          err.number = (ref2 = (ref3 = message.info) != null ? ref3.number : void 0) != null ? ref2 : message.code;\n          err.lineNumber = (ref4 = message.info) != null ? ref4.lineNumber : void 0;\n          err.state = (ref5 = (ref6 = message.info) != null ? ref6.state : void 0) != null ? ref5 : message.sqlstate;\n          err[\"class\"] = (ref7 = (ref8 = message.info) != null ? ref8[\"class\"] : void 0) != null ? ref7 : (ref9 = message.info) != null ? ref9.severity : void 0;\n          err.serverName = (ref10 = message.info) != null ? ref10.serverName : void 0;\n          err.procName = (ref11 = message.info) != null ? ref11.procName : void 0;\n          Object.defineProperty(err, 'originalError', {\n            value: message\n          });\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        } else {\n          err = new RequestError(message);\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        }\n      }\n      this.name = this.constructor.name;\n      this.message = message;\n      if (code != null) {\n        this.code = code;\n      }\n      RequestError.__super__.constructor.call(this);\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    return RequestError;\n\n  })(Error);\n\n  PreparedStatementError = (function(superClass) {\n    extend(PreparedStatementError, superClass);\n\n    function PreparedStatementError(message, code) {\n      var err;\n      if (!(this instanceof PreparedStatementError)) {\n        if (message instanceof Error) {\n          err = new PreparedStatementError(message.message, message.code);\n          err.originalError = message;\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        } else {\n          err = new PreparedStatementError(message);\n          Error.captureStackTrace(err, arguments.callee);\n          return err;\n        }\n      }\n      this.name = this.constructor.name;\n      this.message = message;\n      this.code = code;\n      PreparedStatementError.__super__.constructor.call(this);\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    return PreparedStatementError;\n\n  })(Error);\n\n\n  /*\n  Open global connection.\n  \n  @param {Object} config Connection configuration.\n  @callback callback A callback which is called after connection has established, or an error has occurred.\n  \t@param {Error} err Error on error, otherwise null.\n  \t\n  @returns {Connection}\n   */\n\n  module.exports.connect = function(config, callback) {\n    global_connection = new Connection(config);\n    return global_connection.connect(callback);\n  };\n\n\n  /*\n  Close global connection.\n  \t\n  @returns {Connection}\n   */\n\n  module.exports.close = function(callback) {\n    return global_connection != null ? global_connection.close(callback) : void 0;\n  };\n\n\n  /*\n  Attach evnet handler to global connection.\n  \n  @param {String} event Event name.\n  @param {Function} handler Event handler.\n  @returns {Connection}\n   */\n\n  module.exports.on = function(event, handler) {\n    return global_connection != null ? global_connection.on(event, handler) : void 0;\n  };\n\n\n  /*\n  Creates a new query using global connection from a tagged template string.\n  \n  @param {Array} strings Array of string literals.\n  @param {...*} keys Values.\n  @returns {Request}\n   */\n\n  module.exports.query = function() {\n    var strings, values;\n    strings = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return new Request()._template('query', strings, values);\n  };\n\n\n  /*\n  Creates a new batch using global connection from a tagged template string.\n  \n  @param {Array} strings Array of string literals.\n  @param {...*} keys Values.\n  @returns {Request}\n   */\n\n  module.exports.batch = function() {\n    var strings, values;\n    strings = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return new Request()._template('batch', strings, values);\n  };\n\n  module.exports.Connection = Connection;\n\n  module.exports.Transaction = Transaction;\n\n  module.exports.Request = Request;\n\n  module.exports.Table = Table;\n\n  module.exports.PreparedStatement = PreparedStatement;\n\n  module.exports.ConnectionError = ConnectionError;\n\n  module.exports.TransactionError = TransactionError;\n\n  module.exports.RequestError = RequestError;\n\n  module.exports.PreparedStatementError = PreparedStatementError;\n\n  module.exports.ISOLATION_LEVEL = ISOLATION_LEVEL;\n\n  module.exports.DRIVERS = DRIVERS;\n\n  module.exports.TYPES = TYPES;\n\n  module.exports.MAX = 65535;\n\n  module.exports.map = map;\n\n  module.exports.fix = true;\n\n  module.exports.Promise = (ref1 = global.Promise) != null ? ref1 : require('promise');\n\n  for (key in TYPES) {\n    value = TYPES[key];\n    module.exports[key] = value;\n    module.exports[key.toUpperCase()] = value;\n  }\n\n  module.exports.pool = {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  };\n\n  module.exports.connection = {\n    userName: '',\n    password: '',\n    server: ''\n  };\n\n\n  /*\n  Initialize Tedious connection pool.\n  \n  @deprecated\n   */\n\n  module.exports.init = function() {\n    return module.exports.connect({\n      user: module.exports.connection.userName,\n      password: module.exports.connection.password,\n      server: module.exports.connection.server,\n      options: module.exports.connection.options,\n      driver: 'tedious',\n      pool: module.exports.pool\n    });\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/lib/datatypes.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var TYPES, fn, key, value, zero;\n\n  TYPES = {\n    VarChar: function(length) {\n      return {\n        type: TYPES.VarChar,\n        length: length\n      };\n    },\n    NVarChar: function(length) {\n      return {\n        type: TYPES.NVarChar,\n        length: length\n      };\n    },\n    Text: function() {\n      return {\n        type: TYPES.Text\n      };\n    },\n    Int: function() {\n      return {\n        type: TYPES.Int\n      };\n    },\n    BigInt: function() {\n      return {\n        type: TYPES.BigInt\n      };\n    },\n    TinyInt: function() {\n      return {\n        type: TYPES.TinyInt\n      };\n    },\n    SmallInt: function() {\n      return {\n        type: TYPES.SmallInt\n      };\n    },\n    Bit: function() {\n      return {\n        type: TYPES.Bit\n      };\n    },\n    Float: function() {\n      return {\n        type: TYPES.Float\n      };\n    },\n    Numeric: function(precision, scale) {\n      return {\n        type: TYPES.Numeric,\n        precision: precision,\n        scale: scale\n      };\n    },\n    Decimal: function(precision, scale) {\n      return {\n        type: TYPES.Decimal,\n        precision: precision,\n        scale: scale\n      };\n    },\n    Real: function() {\n      return {\n        type: TYPES.Real\n      };\n    },\n    Date: function() {\n      return {\n        type: TYPES.Date\n      };\n    },\n    DateTime: function() {\n      return {\n        type: TYPES.DateTime\n      };\n    },\n    DateTime2: function(scale) {\n      return {\n        type: TYPES.DateTime2,\n        scale: scale\n      };\n    },\n    DateTimeOffset: function(scale) {\n      return {\n        type: TYPES.DateTimeOffset,\n        scale: scale\n      };\n    },\n    SmallDateTime: function() {\n      return {\n        type: TYPES.SmallDateTime\n      };\n    },\n    Time: function(scale) {\n      return {\n        type: TYPES.Time,\n        scale: scale\n      };\n    },\n    UniqueIdentifier: function() {\n      return {\n        type: TYPES.UniqueIdentifier\n      };\n    },\n    SmallMoney: function() {\n      return {\n        type: TYPES.SmallMoney\n      };\n    },\n    Money: function() {\n      return {\n        type: TYPES.Money\n      };\n    },\n    Binary: function(length) {\n      return {\n        type: TYPES.Binary,\n        length: length\n      };\n    },\n    VarBinary: function(length) {\n      return {\n        type: TYPES.VarBinary,\n        length: length\n      };\n    },\n    Image: function() {\n      return {\n        type: TYPES.Image\n      };\n    },\n    Xml: function() {\n      return {\n        type: TYPES.Xml\n      };\n    },\n    Char: function(length) {\n      return {\n        type: TYPES.Char,\n        length: length\n      };\n    },\n    NChar: function(length) {\n      return {\n        type: TYPES.NChar,\n        length: length\n      };\n    },\n    NText: function() {\n      return {\n        type: TYPES.NText\n      };\n    },\n    TVP: function(tvpType) {\n      return {\n        type: TYPES.TVP,\n        tvpType: tvpType\n      };\n    },\n    UDT: function() {\n      return {\n        type: TYPES.UDT\n      };\n    },\n    Geography: function() {\n      return {\n        type: TYPES.Geography\n      };\n    },\n    Geometry: function() {\n      return {\n        type: TYPES.Geometry\n      };\n    },\n    Variant: function() {\n      return {\n        type: TYPES.Variant\n      };\n    }\n  };\n\n  module.exports.TYPES = TYPES;\n\n  module.exports.DECLARATIONS = {};\n\n  fn = function(key, value) {\n    return value.inspect = function() {\n      return \"[sql.\" + key + \"]\";\n    };\n  };\n  for (key in TYPES) {\n    value = TYPES[key];\n    value.declaration = key.toLowerCase();\n    module.exports.DECLARATIONS[value.declaration] = value;\n    fn(key, value);\n  }\n\n  module.exports.declare = function(type, options) {\n    var ref, ref1, ref2, ref3, ref4, ref5;\n    switch (type) {\n      case TYPES.VarChar:\n      case TYPES.NVarChar:\n      case TYPES.VarBinary:\n        return type.declaration + \" (\" + (options.length > 8000 ? 'MAX' : (ref = options.length) != null ? ref : 'MAX') + \")\";\n      case TYPES.NVarChar:\n        return type.declaration + \" (\" + (options.length > 4000 ? 'MAX' : (ref1 = options.length) != null ? ref1 : 'MAX') + \")\";\n      case TYPES.Char:\n      case TYPES.NChar:\n      case TYPES.Binary:\n        return type.declaration + \" (\" + ((ref2 = options.length) != null ? ref2 : 1) + \")\";\n      case TYPES.Decimal:\n      case TYPES.Numeric:\n        return type.declaration + \" (\" + ((ref3 = options.precision) != null ? ref3 : 18) + \", \" + ((ref4 = options.scale) != null ? ref4 : 0) + \")\";\n      case TYPES.Time:\n      case TYPES.DateTime2:\n      case TYPES.DateTimeOffset:\n        return type.declaration + \" (\" + ((ref5 = options.scale) != null ? ref5 : 7) + \")\";\n      case TYPES.TVP:\n        return options.tvpType + \" readonly\";\n      default:\n        return type.declaration;\n    }\n  };\n\n  module.exports.cast = function(value, type, options) {\n    var ns, ref, scale;\n    if (value == null) {\n      return null;\n    }\n    switch (typeof value) {\n      case 'string':\n        return \"N'\" + (value.replace(/'/g, '\\'\\'')) + \"'\";\n      case 'number':\n        return value;\n      case 'boolean':\n        if (value) {\n          return 1;\n        } else {\n          return 0;\n        }\n      case 'object':\n        if (value instanceof Date) {\n          ns = value.getUTCMilliseconds() / 1000;\n          if (value.nanosecondDelta != null) {\n            ns += value.nanosecondDelta;\n          }\n          scale = (ref = options.scale) != null ? ref : 7;\n          if (scale > 0) {\n            ns = String(ns).substr(1, scale + 1);\n          } else {\n            ns = \"\";\n          }\n          return \"N'\" + (value.getUTCFullYear()) + \"-\" + (zero(value.getUTCMonth() + 1)) + \"-\" + (zero(value.getUTCDate())) + \" \" + (zero(value.getUTCHours())) + \":\" + (zero(value.getUTCMinutes())) + \":\" + (zero(value.getUTCSeconds())) + ns + \"'\";\n        } else if (Buffer.isBuffer(value)) {\n          return \"0x\" + (value.toString('hex'));\n        } else {\n          return null;\n        }\n        break;\n      default:\n        return null;\n    }\n  };\n\n  zero = function(value, length) {\n    var i, j, ref;\n    if (length == null) {\n      length = 2;\n    }\n    value = String(value);\n    if (value.length < length) {\n      for (i = j = 1, ref = length - value.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n        value = \"0\" + value;\n      }\n    }\n    return value;\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/lib/isolationlevel.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  module.exports = {\n    READ_UNCOMMITTED: 0x01,\n    READ_COMMITTED: 0x02,\n    REPEATABLE_READ: 0x03,\n    SERIALIZABLE: 0x04,\n    SNAPSHOT: 0x05\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/lib/table.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var JSON_COLUMN_ID, MAX, TYPES, Table, declare, ref,\n    slice = [].slice;\n\n  ref = require('./datatypes'), TYPES = ref.TYPES, declare = ref.declare;\n\n  MAX = 65535;\n\n  JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\n\n  Table = (function() {\n    function Table(name) {\n      var ref1;\n      if (name) {\n        ref1 = Table.parseName(name), this.name = ref1.name, this.schema = ref1.schema, this.database = ref1.database;\n        this.path = \"\" + (this.database ? \"[\" + this.database + \"].\" : \"\") + (this.schema ? \"[\" + this.schema + \"].\" : \"\") + \"[\" + this.name + \"]\";\n        this.temporary = this.name.charAt(0) === '#';\n      }\n      this.columns = [];\n      this.rows = [];\n      Object.defineProperty(this.columns, \"add\", {\n        value: function(name, column, options) {\n          if (options == null) {\n            options = {};\n          }\n          if (column == null) {\n            throw new Error(\"Column data type is not defined.\");\n          }\n          if (column instanceof Function) {\n            column = column();\n          }\n          column.name = name;\n          column.nullable = options.nullable;\n          column.primary = options.primary;\n          return this.push(column);\n        }\n      });\n      Object.defineProperty(this.rows, \"add\", {\n        value: function() {\n          var values;\n          values = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return this.push(values);\n        }\n      });\n    }\n\n\n    /*\n    \t@private\n     */\n\n    Table.prototype._makeBulk = function() {\n      var col, i, len, ref1;\n      ref1 = this.columns;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        col = ref1[i];\n        switch (col.type) {\n          case TYPES.Xml:\n            col.type = TYPES.NVarChar(MAX).type;\n            break;\n          case TYPES.UDT:\n          case TYPES.Geography:\n          case TYPES.Geometry:\n            col.type = TYPES.VarBinary(MAX).type;\n        }\n      }\n      return this;\n    };\n\n    Table.prototype.declare = function() {\n      var cols, pkey;\n      pkey = this.columns.filter(function(col) {\n        return col.primary === true;\n      }).map(function(col) {\n        return col.name;\n      });\n      cols = this.columns.map(function(col) {\n        var def;\n        def = [\"[\" + col.name + \"] \" + (declare(col.type, col))];\n        if (col.nullable === true) {\n          def.push(\"null\");\n        } else if (col.nullable === false) {\n          def.push(\"not null\");\n        }\n        if (col.primary === true && pkey.length === 1) {\n          def.push(\"primary key\");\n        }\n        return def.join(' ');\n      });\n      return \"create table \" + this.path + \" (\" + (cols.join(', ')) + (pkey.length > 1 ? \", constraint PK_\" + (this.temporary ? this.name.substr(1) : this.name) + \" primary key (\" + (pkey.join(', ')) + \")\" : \"\") + \")\";\n    };\n\n    Table.fromRecordset = function(recordset, name) {\n      var col, i, j, len, len1, ref1, ref2, row, t;\n      t = new this(name);\n      ref1 = recordset.columns;\n      for (name in ref1) {\n        col = ref1[name];\n        t.columns.add(name, {\n          type: col.type,\n          length: col.length,\n          scale: col.scale,\n          precision: col.precision\n        }, {\n          nullable: col.nullable\n        });\n      }\n      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {\n        for (i = 0, len = recordset.length; i < len; i++) {\n          row = recordset[i];\n          t.rows.add(JSON.stringify(row));\n        }\n      } else {\n        for (j = 0, len1 = recordset.length; j < len1; j++) {\n          row = recordset[j];\n          (ref2 = t.rows).add.apply(ref2, (function() {\n            var k, len2, ref2, results;\n            ref2 = t.columns;\n            results = [];\n            for (k = 0, len2 = ref2.length; k < len2; k++) {\n              col = ref2[k];\n              results.push(row[col.name]);\n            }\n            return results;\n          })());\n        }\n      }\n      return t;\n    };\n\n    Table.parseName = function(name) {\n      var buffer, char, cursor, escaped, length, path;\n      length = name.length;\n      cursor = -1;\n      buffer = '';\n      escaped = false;\n      path = [];\n      while (++cursor < length) {\n        char = name.charAt(cursor);\n        if (char === '[') {\n          if (escaped) {\n            buffer += char;\n          } else {\n            escaped = true;\n          }\n        } else if (char === ']') {\n          if (escaped) {\n            escaped = false;\n          } else {\n            throw new Error(\"Invalid table name.\");\n          }\n        } else if (char === '.') {\n          if (escaped) {\n            buffer += char;\n          } else {\n            path.push(buffer);\n            buffer = '';\n          }\n        } else {\n          buffer += char;\n        }\n      }\n      if (buffer) {\n        path.push(buffer);\n      }\n      switch (path.length) {\n        case 1:\n          return {\n            name: path[0],\n            schema: null,\n            database: null\n          };\n        case 2:\n          return {\n            name: path[1],\n            schema: path[0],\n            database: null\n          };\n        case 3:\n          return {\n            name: path[2],\n            schema: path[1],\n            database: path[0]\n          };\n        default:\n          throw new Error(\"Invalid table name.\");\n      }\n    };\n\n    return Table;\n\n  })();\n\n  module.exports = Table;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/node_modules/mssql/lib/connectionstring.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var IGNORE_KEYS, parseConnectionString, parseConnectionURI, qs, resolveConnectionString, url,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  url = require('url');\n\n  qs = require('querystring');\n\n  IGNORE_KEYS = ['stream'];\n\n  parseConnectionURI = function(uri) {\n    var instance, key, object, parsed, password, path, ref, user, value;\n    parsed = url.parse(uri);\n    path = parsed.pathname.substr(1).split('/');\n    if (path.length > 1) {\n      instance = path.shift();\n    }\n    if (parsed.auth) {\n      parsed.auth = parsed.auth.split(':');\n      user = parsed.auth.shift();\n      password = parsed.auth.join(':');\n    }\n    object = {\n      server: \"\" + parsed.hostname + (parsed.port ? \",\" + parsed.port : instance ? \"\\\\\" + instance : \"\"),\n      uid: user || '',\n      pwd: password || '',\n      database: path[0]\n    };\n    if (parsed.query) {\n      ref = qs.parse(parsed.query);\n      for (key in ref) {\n        value = ref[key];\n        if (key === 'domain') {\n          object.uid = value + \"\\\\\" + object.uid;\n        } else {\n          object[key] = value;\n        }\n      }\n    }\n    Object.defineProperty(object, 'toString', {\n      value: function() {\n        return ((function() {\n          var results;\n          results = [];\n          for (key in this) {\n            value = this[key];\n            if (indexOf.call(IGNORE_KEYS, key) < 0) {\n              results.push(key + \"={\" + value + \"}\");\n            }\n          }\n          return results;\n        }).call(this)).join(';');\n      }\n    });\n    return object;\n  };\n\n  parseConnectionString = function(string) {\n    var buffer, char, cursor, original, param, parsed, parsing, quotes;\n    cursor = 0;\n    parsing = 'name';\n    param = null;\n    buffer = '';\n    quotes = null;\n    parsed = {};\n    original = {};\n    Object.defineProperty(parsed, '__original__', {\n      value: original\n    });\n    Object.defineProperty(parsed, 'toString', {\n      value: function() {\n        var key, value;\n        return ((function() {\n          var ref, ref1, ref2, ref3, results;\n          results = [];\n          for (key in this) {\n            value = this[key];\n            if (indexOf.call(IGNORE_KEYS, key) < 0) {\n              results.push(original[key].name + \"=\" + ((ref = (ref1 = original[key].escape) != null ? ref1[0] : void 0) != null ? ref : '') + value + ((ref2 = (ref3 = original[key].escape) != null ? ref3[1] : void 0) != null ? ref2 : ''));\n            }\n          }\n          return results;\n        }).call(this)).join(';');\n      }\n    });\n    while (cursor < string.length) {\n      char = string.charAt(cursor);\n      switch (char) {\n        case '=':\n          if (parsing === 'name') {\n            buffer = buffer.trim();\n            param = buffer.toLowerCase();\n            original[param] = {\n              name: buffer\n            };\n            parsing = 'value';\n            buffer = '';\n          } else {\n            buffer += char;\n          }\n          break;\n        case '\\'':\n        case '\"':\n          if (parsing === 'value') {\n            if (!buffer.trim().length) {\n              original[param].escape = [char, char];\n              quotes = char;\n              buffer = '';\n            } else {\n              if (quotes) {\n                if (char === quotes) {\n                  if (char === string.charAt(cursor + 1)) {\n                    buffer += char;\n                    cursor++;\n                  } else {\n                    parsed[param] = buffer;\n                    param = null;\n                    parsing = null;\n                    buffer = '';\n                    quotes = null;\n                  }\n                } else {\n                  buffer += char;\n                }\n              } else {\n                buffer += char;\n              }\n            }\n          } else {\n            throw new Error(\"Invalid connection string.\");\n          }\n          break;\n        case '{':\n          if (parsing === 'value') {\n            if (!buffer.trim().length) {\n              original[param].escape = ['{', '}'];\n              quotes = '{}';\n              buffer = '';\n            } else {\n              buffer += char;\n            }\n          } else {\n            throw new Error(\"Invalid connection string.\");\n          }\n          break;\n        case '}':\n          if (parsing === 'value') {\n            if (quotes === '{}') {\n              parsed[param] = buffer;\n              param = null;\n              parsing = null;\n              buffer = '';\n              quotes = null;\n            } else {\n              buffer += char;\n            }\n          } else {\n            throw new Error(\"Invalid connection string.\");\n          }\n          break;\n        case ';':\n          if (parsing === 'value') {\n            if (quotes) {\n              buffer += char;\n            } else {\n              parsed[param] = buffer;\n              param = null;\n              parsing = 'name';\n              buffer = '';\n            }\n          } else {\n            buffer = '';\n            parsing = 'name';\n          }\n          break;\n        default:\n          buffer += char;\n      }\n      cursor++;\n    }\n    if (parsing === 'value') {\n      parsed[param] = buffer;\n    }\n    return parsed;\n  };\n\n  resolveConnectionString = function(string) {\n    var config, parsed, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, server, user;\n    if (/^(mssql|tedious|msnodesql|tds)\\:\\/\\//i.test(string)) {\n      parsed = parseConnectionURI(string);\n    } else {\n      parsed = parseConnectionString(string);\n    }\n    if (parsed.driver === 'msnodesql') {\n      parsed.driver = 'SQL Server Native Client 11.0';\n      if ((ref = parsed.__original__) != null) {\n        ref.driver = {\n          name: 'Driver',\n          escape: ['{', '}']\n        };\n      }\n      return {\n        driver: 'msnodesql',\n        connectionString: parsed.toString()\n      };\n    }\n    user = (ref1 = parsed.uid) != null ? ref1 : parsed['user id'];\n    server = (ref2 = (ref3 = (ref4 = (ref5 = parsed.server) != null ? ref5 : parsed.address) != null ? ref4 : parsed.addr) != null ? ref3 : parsed['data source']) != null ? ref2 : parsed['network address'];\n    config = {\n      driver: parsed.driver,\n      password: (ref6 = parsed.pwd) != null ? ref6 : parsed.password,\n      database: (ref7 = parsed.database) != null ? ref7 : parsed['initial catalog'],\n      connectionTimeout: (ref8 = (ref9 = (ref10 = parsed.connectionTimeout) != null ? ref10 : parsed.timeout) != null ? ref9 : parsed['connect timeout']) != null ? ref8 : parsed['connection timeout'],\n      requestTimeout: (ref11 = parsed.requestTimeout) != null ? ref11 : parsed['request timeout'],\n      stream: (ref12 = (ref13 = parsed.stream) != null ? ref13.toLowerCase() : void 0) === 'true' || ref12 === 'yes' || ref12 === '1',\n      options: {\n        encrypt: (ref14 = (ref15 = parsed.encrypt) != null ? ref15.toLowerCase() : void 0) === 'true' || ref14 === 'yes' || ref14 === '1'\n      }\n    };\n    if (parsed.useUTC != null) {\n      config.options.useUTC = (ref16 = parsed.useUTC.toLowerCase()) === 'true' || ref16 === 'yes' || ref16 === '1';\n    }\n    if (config.connectionTimeout != null) {\n      config.connectionTimeout = parseInt(config.connectionTimeout);\n    }\n    if (config.requestTimeout != null) {\n      config.requestTimeout = parseInt(config.requestTimeout);\n    }\n    if (/^(.*)\\\\(.*)$/.exec(user)) {\n      config.domain = RegExp.$1;\n      user = RegExp.$2;\n    }\n    if (server) {\n      server = server.trim();\n      if (/^np\\:/i.test(server)) {\n        throw new Error(\"Connection via Named Pipes is not supported.\");\n      }\n      if (/^tcp\\:/i.test(server)) {\n        server = server.substr(4);\n      }\n      if (/^(.*)\\\\(.*)$/.exec(server)) {\n        server = RegExp.$1;\n        config.options.instanceName = RegExp.$2;\n      }\n      if (/^(.*),(.*)$/.exec(server)) {\n        server = RegExp.$1.trim();\n        config.port = parseInt(RegExp.$2.trim());\n      }\n      if ((ref17 = server.toLowerCase()) === '.' || ref17 === '(.)' || ref17 === '(localdb)' || ref17 === '(local)') {\n        server = 'localhost';\n      }\n    }\n    config.user = user;\n    config.server = server;\n    return config;\n  };\n\n  module.exports = {\n    parse: parseConnectionString,\n    resolve: resolveConnectionString\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/options.js":"(function () {\n    \"use strict\";\n\n    var pjson = require('../package.json'),\n        path = require('path'),\n        fs = require('fs'),\n        _ = require('underscore'),\n        sprintf = require(\"sprintf-js\").sprintf,\n        passPrompt = require('password-prompt');\n\n    var DEFAULT_CONFIG = 'mssql-conf.json';\n\n    class Options {\n        constructor() {\n            this.version = pjson.version;\n        }\n\n        init(argv, env) {\n            return new Promise((resolve, reject)=>\n            {\n                var program = require('commander');\n\n                program.version(this.version)\n                    .option('-s, --server <server>', 'Server to conect to')\n                    .option('-u, --user <user>', 'User name to use for authentication')\n                    .option('-p, --pass [pass]', 'Password to use for authentication')\n                    .option('-o, --port <port>', 'Port to connect to')\n                    .option('-t, --timeout <timeout>', 'Connection timeout in ms')\n                    .option('-T, --requestTimeout <timeout>', 'Request timeout in ms')\n                    .option('-d, --database <database>', 'Database to connect to')\n                    .option('-q, --query <query>', 'The query to execute')\n                    .option('-v, --tdsVersion <tdsVersion>', 'Version of tds protocol to use [7_4, 7_2, 7_3_A, 7_3_B, 7_4]')\n                    .option('-e, --encrypt', 'Enable encryption')\n                    .option('-f, --format <format>', 'The format of output [table, csv, xml, json]')\n                    .option('-c, --config <path>', 'Read connection information from config file');\n\n                program.parse(argv);\n\n                this.env = env;\n                this.args = {};\n                _.extend(this.args, _.pick(program, 'server', 'user', 'pass',\n                    'port', 'requestTimeout', 'timeout',\n                    'database', 'query', 'tdsVersion',\n                    'encrypt', 'format', 'config'));\n\n                if (this.args.config && !fs.existsSync(this.args.config)) {\n                    reject(sprintf('config file \\'%s\\' does not exist.', this.args.config));\n                }\n                // if -p or --pass option is specified without a value then prompt\n                else if (this.args.pass === true) {\n                    return passPrompt('Enter password: ', { method: 'hide' }).then(pass => {\n                        this.args.pass = pass;\n                        resolve();\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        }\n\n        getConnectionInfo() {\n            var args = this.args || {},\n                env = this.env || {},\n                configPath = args.config || DEFAULT_CONFIG;\n\n            var config = {};\n\n            if (fs.existsSync(configPath)) {\n                config = require(path.resolve(configPath));\n            }\n\n            var defaults = {\n                user: env.SQLCLI_USER || 'sa',\n                pass: env.SQLCLI_PASSWORD,\n                server: env.SQLCLI_SERVER || 'localhost',\n                database: env.SQLCLI_DATABASE,\n                port: env.SQLCLI_PORT,\n                timeout: env.SQLCLI_TIMEOUT,\n                requestTimeout: env.SQLCLI_REQUEST_TIMEOUT,\n                tdsVersion: env.SQLCLI_TDSVERSION,\n                encrypt: env.SQLCLI_ENCRYPT,\n            };\n\n            config = _.extend({}, defaults, config, args);\n\n            var connectInfo = {\n                user: config.user,\n                password: config.pass,\n                server: config.server,\n                database: config.database,\n                timeout: config.timeout,\n                requestTimeout: config.requestTimeout,\n                options: {\n                    port: config.port,\n                    tdsVersion: config.tdsVersion,\n                    encrypt: !!config.encrypt\n                },\n                pool: {\n                    max: 1,\n                    min: 1\n                }\n            };\n\n            return connectInfo;\n        }\n    }\n\n    module.exports = exports = Options;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/index.js":"(function () {\n    \"use strict\";\n\n    var _str = require('underscore.string');\n\n    function createAll(db) {\n        var commands = [];\n        Object.keys(module.exports).forEach(k => {\n            if (_str.endsWith(k, 'Command')) {\n                commands.push(new module.exports[k](db));\n            }\n        });\n        return commands;\n    }\n\n    module.exports = exports = {\n        Invoker: require('./invoker'),\n        Buffer: require('./buffer'),\n        Queue: require('./queue'),\n        createAll: createAll,\n        HelpCommand: require('./help'),\n        DatabasesCommand: require('./databases'),\n        TablesCommand: require('./tables'),\n        SprocsCommand: require('./sprocs'),\n        SearchCommand: require('./search'),\n        IndexesCommand: require('./indexes'),\n        ReadCommand: require('./read'),\n        RunCommand: require('./run'),\n        SchemaCommand: require('./schema'),\n        AnalyzeCommand: require('./analyze'),\n        QuitCommand: require('./quit'),\n        Utils: require('./utils')\n    };\n\n} ());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/invoker.js":"(function () {\n    \"use strict\";\n\n    var _ = require('underscore'),\n        QueryCommand = require('./query');\n\n    class Invoker {\n        constructor(db, messages, writer) {\n            this.writer = writer;\n            this.messages = messages;\n            this.commands = require('./index').createAll(db);\n\n            this.default = new QueryCommand(db);\n        }\n\n        run(line) {\n            var tokens = line.split(' ');\n\n            var cmd = _.findWhere(this.commands, { prefix: tokens[0] });\n            if (cmd) {\n                return cmd.run(this.messages, this.writer, tokens.splice(1));\n            }\n            return this.default.run(this.messages, this.writer, line);\n        }\n    }\n\n    module.exports = exports = Invoker;\n\n} ()); ","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/query.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils');\n\n    class QueryCommand {\n        constructor(db) {\n            this.db = db;\n        }\n\n        run(messages, writer, sql) {\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, sql));\n        }\n    }\n\n    module.exports = exports = QueryCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/utils.js":"(function () {\n    \"use strict\";\n\n    var readline = require('readline'),\n        Q = require('q'),\n        iconv = require('iconv-lite'),\n        chardet = require('chardet'),\n        fs = require('fs'),\n        _str = require('underscore.string');\n\n    class Utils {\n        static runQuery(messages, writer, query) {\n            var start = new Date().getTime();\n            var request = query();\n            var deferred = Q.defer();\n            var resultsets = 0;\n            var rowCount = 0;\n            var error = null;\n            var rows = null;\n            var rowsEmitted = false;            \n\n            var startRecordset = () => {\n                writer.startSet();\n                rows = [];\n                rowCount = 0;\n                resultsets++;\n            };\n\n            var finishRecordset = () => {\n                if (rows.length > 0) {\n                    writer.writeRows(rows);\n                }\n                writer.endSet();\n\n                if (writer.freeFormat) {\n                    messages.rowCount(rowCount, writer.appendsLineToResult);\n                }\n            };\n\n            request.on('recordset', recordset => {\n                if (!rowsEmitted) {\n                    rowsEmitted = true;\n                    writer.startResult();\n                }\n                else {\n                    finishRecordset();\n                }\n                startRecordset();\n            });\n\n            request.on('row', row => {\n                rows.push(row);\n                rowCount++;\n                if (rows.length == messages.pageSize) {\n                    writer.writeRows(rows);\n                    rows = [];\n                }\n            });\n\n            request.on('error', err => {\n                error = err;\n                deferred.reject(err);\n            });\n\n            request.on('done', returnValue => {\n                if (!error) {\n                    if (rowsEmitted === false) {\n                        messages.done(); // show 'done' on console for non-queries\n                    }\n                    else {\n                        finishRecordset(); // purge last result\n                    }\n                    var elapsed = new Date().getTime() - start;\n                    writer.endResult(); // i.e. add closing tag of output xml\n                    messages.resultsetsEnd(resultsets, elapsed); // show elapsed time on console     \n                    deferred.resolve(resultsets);\n                }\n            });\n\n            return deferred.promise;\n        }\n\n        static isContinued(line) {\n            return line.substring(line.length - 1) == '\\\\';\n        }\n\n        static trimSlash(line) {\n            if (!line) return;\n\n            return line.substring(0, line.length - 1);\n        }\n\n        static appendLine(buffer, line) {\n            if (buffer) {\n                buffer += '\\r\\n';\n            }\n            buffer += line;\n            return buffer;\n        }\n\n        static validateArgs(args, minCount) {\n            return args && Array.isArray(args) && args.length >= minCount;\n        }\n\n        static detectEncoding(file) {\n            var buffer = new Buffer(100);\n            buffer.fill(0);\n            var fd = fs.openSync(file, 'r');\n            fs.readSync(fd, buffer, 0, 100);\n            return chardet.detect(buffer);\n        }\n\n        static readFile(deferred, file) {\n            var stream;\n\n            file = file.trim();\n\n            try {\n                var encoding = Utils.detectEncoding(file);\n                stream = fs.createReadStream(file)\n                    .pipe(iconv.decodeStream(encoding));\n            } catch (err) {\n                deferred.reject(err);\n                return null;\n            }\n\n            function onError(err) {\n                deferred.reject(err);\n            }\n            stream.on('error', onError);\n\n            var reader = new readline.createInterface({\n                input: stream\n            });\n            reader.on('error', onError);\n\n            return reader;\n        }\n    }\n\n    module.exports = exports = Utils;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/buffer.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils');\n\n    const EventEmitter = require('events');\n\n    class Buffer extends EventEmitter {\n        constructor() {\n            super();\n            \n            this.buffer = '';\n        }\n\n        addLine(line) {\n            let complete = !Utils.isContinued(line);\n            \n            if (complete) {\n                this.buffer = Utils.appendLine(this.buffer, line);\n                this.flush();    \n            }\n            else {\n                line = Utils.trimSlash(line);\n                this.buffer = Utils.appendLine(this.buffer, line);\n            }\n\n            return complete;\n        }\n\n        flush() {\n            this.emit('command', this.buffer);\n            this.buffer = '';\n        }\n    }\n\n    module.exports = exports = Buffer;\n\n} ()); ","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/queue.js":"(function () {\n    \"use strict\";\n\n    class Queue {\n        constructor(invoker, prompt, messages) {\n            this.invoker = invoker;\n            this.prompt = prompt;\n            this.messages = messages;\n            this.commands = [];\n            this.errorCode = 0;\n        }\n\n        addCommand(cmd) {\n            this.commands.push(cmd);\n            // if this is the only command\n            // then no one else is going to\n            // call the next method so call\n            // it ourselves here\n            if (this.commands.length === 1) {\n                this._next();\n            }\n        }\n\n        end() {\n            this.prompt.exit = true;\n            // if there is no pending command\n            // then next will not be called\n            // so call it now\n            if (this.commands.length === 0) {\n                this._next();\n            }\n        }\n\n        _next() {\n            if (this.commands.length === 0) {\n                // now that we're done with all \n                // the pending commands, we can\n                // ask for more input from user\n                return this.prompt.next(this.errorCode);\n            }\n            \n            let cmd = this.commands[0];\n            this.invoker.run(cmd)\n                .then(()=> {\n                    this.errorCode = 0;\n                }, err => {\n                    this.messages.error(err);\n                    this.errorCode = -1;\n                }).finally(()=> {\n                    this.commands.shift();\n                    this._next();\n                });\n        }\n    }\n\n    module.exports = exports = Queue;\n\n} ()); ","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/help.js":"(function () {\n    \"use strict\";\n\n    var Q = require('q');\n\n    class HelpCommand {\n        constructor() {\n            this.prefix = '.help';\n            this.usage = '.help';\n            this.description = 'Shows this message';\n        }\n\n        run(messages, writer) {\n            var commands = require('./index').createAll(null /*db*/);\n\n            var doc = commands.map(cmd => {\n                return {\n                    command: cmd.usage,\n                    description: cmd.description\n                };\n            });\n            writer.writeRows(doc);\n\n            return new Q(); // resolved promise\n        }\n    }\n\n    module.exports = exports = HelpCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/databases.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries');\n\n    class DatabasesCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.databases';\n            this.usage = '.databases';\n            this.description = 'Lists all the databases';\n        }\n\n        run(messages, writer) {\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.listDatabasesSql()));\n        }\n    }\n\n    module.exports = exports = DatabasesCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/queries.js":"(function () {\n\t\"use strict\";\n\n\tvar _ = require('underscore'),\n\t\tmstring = require('mstring'),\n\t\tsprintf = require(\"sprintf-js\").sprintf;\n\n\tclass Queries {\n\t\tstatic getSchemaSql(table) {\n\t\t\treturn sprintf(mstring(function () {/***\n\t\t\t\t  SELECT COLUMN_NAME name,\n\t\t\t\t\tCOLUMN_DEFAULT [default],\n\t\t\t\t\tIS_NULLABLE nullable,\n\t\t\t\t\t(DATA_TYPE + (CASE WHEN CHARINDEX('char', DATA_TYPE) = 0 THEN '' ELSE '(' + CAST(CHARACTER_MAXIMUM_LENGTH as VARCHAR(16)) + ')' END)) type,\n\t\t\t\t\tCOL_LENGTH(OBJECT_SCHEMA_NAME(OBJECT_ID('%1$s')) + '.' + OBJECT_NAME(OBJECT_ID('%1$s')), COLUMN_NAME) length,\n\t\t\t\t\t(SELECT CASE WHEN count(1) > 0 THEN 'YES' ELSE 'NO' END\n\t\t\t\t\t\tFROM sys.index_columns ic\n\t\t\t\t\t\tWHERE ic.object_id = OBJECT_ID('%1$s') AND\n\t\t\t\t\t\t\tic.column_id=COLUMNPROPERTY(OBJECT_ID('%1$s'), COLUMN_NAME, 'ColumnId') AND\n\t\t\t\t\t\t\tic.key_ordinal = 1) indexed\n\t\t\t\t   FROM INFORMATION_SCHEMA.COLUMNS\n\t\t\t\t   WHERE TABLE_NAME = OBJECT_NAME(OBJECT_ID('%1$s')) AND\n\t\t\t\t\t\t  TABLE_SCHEMA = OBJECT_SCHEMA_NAME(OBJECT_ID('%1$s'))\n\t\t\t\t   ORDER BY name;\n\t\t\t***/}), table);\n\t\t}\n\n\t\tstatic listDatabasesSql() {\n\t\t\treturn mstring(function () {/***\n\t\t\t\tSELECT name FROM sys.databases\n\t\t\t\tORDER BY name;\n\t\t\t***/});\n\t\t}\n\n\t\tstatic listTablesSql() {\n\t\t\treturn mstring(function () {/***\n\t\t\t\tSELECT TABLE_CATALOG [database],\n\t\t\t\t\tTABLE_SCHEMA [schema],\n\t\t\t\t\tTABLE_NAME name,\n\t\t\t\t\tTABLE_TYPE type\n\t\t\t\tFROM INFORMATION_SCHEMA.TABLES\n\t\t\t\tORDER BY name;\n\t\t\t***/});\n\t\t}\n\n\t\tstatic listIndexesSql(table) {\n\t\t\treturn sprintf(mstring(function () {/***\n\t\t\t\tSELECT i.name,\n\t\t\t\t\ti.type_desc type,\n\t\t\t\t\tis_unique [unique],\n\t\t\t\t\tis_primary_key [primary],\n\t\t\t\t\tSTUFF((SELECT ', ' + c.name\n\t\t\t\t\t\t\tFROM sys.index_columns ic\n\t\t\t\t\t\t\tJOIN sys.columns c ON ic.column_id = c.column_id AND ic.object_id = c.object_id\n\t\t\t\t\t\t\tWHERE ic.object_id = i.object_id AND ic.index_id = i.index_id\n\t\t\t\t\t\t\tORDER BY ic.key_ordinal\n\t\t\t\t\t\t\tFOR XML PATH('')), 1, 1, '') columns\n\t\t\t\t FROM sys.indexes i\n\t\t\t\t WHERE i.object_id=OBJECT_ID('%s')\n\t\t\t\t ORDER BY i.name;\n\t\t\t***/}), table);\n\t\t}\n\n\t\tstatic listMissingIndexesSql(table) {\n\t\t\treturn sprintf(mstring(function () {/***\n\t\t\t\tSELECT\n\t\t\t\t\tDB_NAME(mid.database_id) [database],\n\t\t\t\t\tOBJECT_SCHEMA_NAME(mid.[OBJECT_ID]) [schema],\n\t\t\t\t\tOBJECT_NAME(mid.[OBJECT_ID]) [table],\n\t\t\t\t\tmigs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,\n\t\t\t\t\tmid.equality_columns,\n\t\t\t\t\tmid.inequality_columns,\n\t\t\t\t\tmid.included_columns,\n\t\t\t\t\tunique_compiles,\n\t\t\t\t\tuser_seeks,\n\t\t\t\t\tuser_scans,\n\t\t\t\t\tavg_total_user_cost,\n\t\t\t\t\tavg_user_impact,\n\t\t\t\t\tsystem_seeks,\n\t\t\t\t\tsystem_scans,\n\t\t\t\t\tavg_total_system_cost,\n\t\t\t\t\tavg_system_impact\n\t\t\t\tFROM sys.dm_db_missing_index_groups mig\n\t\t\t\tINNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle\n\t\t\t\tINNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle\n\t\t\t\tWHERE migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) > 10\n\t\t\t\tORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC\n\t\t\t***/}), table);\n\t\t}\n\n\t\tstatic listSprocsSql() {\n\t\t\treturn mstring(function () {/***\n\t\t\t\tSELECT\n\t\t\t\t\tSPECIFIC_CATALOG [database],\n\t\t\t\t\tSPECIFIC_SCHEMA [schema],\n\t\t\t\t\tSPECIFIC_NAME name,\n\t\t\t\t\tROUTINE_TYPE type\n\t\t\t\tFROM INFORMATION_SCHEMA.ROUTINES\n\t\t\t\tWHERE ROUTINE_TYPE = 'PROCEDURE'\n\t\t\t\tORDER BY SPECIFIC_NAME;\n\t\t\t***/});\n\t\t}\n\n\t\tstatic searchSql(search) {\n\t\t\treturn sprintf(mstring(function () {/***\n\t\t\t\tDECLARE @SearchStr nvarchar(100)\n\t\t\t\tSET @SearchStr = '%s'\n\n\t\t\t\tCREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630))\n\n\t\t\t\tSET NOCOUNT ON\n\n\t\t\t\tDECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110)\n\t\t\t\tSET  @TableName = ''\n\t\t\t\tSET @SearchStr2 = QUOTENAME('%%' + @SearchStr + '%%','''')\n\n\t\t\t\tWHILE @TableName IS NOT NULL\n\n\t\t\t\tBEGIN\n\t\t\t\t    SET @ColumnName = ''\n\t\t\t\t    SET @TableName =\n\t\t\t\t    (\n\t\t\t\t        SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME))\n\t\t\t\t        FROM     INFORMATION_SCHEMA.TABLES\n\t\t\t\t        WHERE         TABLE_TYPE = 'BASE TABLE'\n\t\t\t\t            AND    QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName\n\t\t\t\t            AND    OBJECTPROPERTY(\n\t\t\t\t                    OBJECT_ID(\n\t\t\t\t                        QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)\n\t\t\t\t                         ), 'IsMSShipped'\n\t\t\t\t                           ) = 0\n\t\t\t\t    )\n\n\t\t\t\t    WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL)\n\n\t\t\t\t    BEGIN\n\t\t\t\t        SET @ColumnName =\n\t\t\t\t        (\n\t\t\t\t            SELECT MIN(QUOTENAME(COLUMN_NAME))\n\t\t\t\t            FROM     INFORMATION_SCHEMA.COLUMNS\n\t\t\t\t            WHERE         TABLE_SCHEMA    = PARSENAME(@TableName, 2)\n\t\t\t\t                AND    TABLE_NAME    = PARSENAME(@TableName, 1)\n\t\t\t\t                AND    DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal')\n\t\t\t\t                AND    QUOTENAME(COLUMN_NAME) > @ColumnName\n\t\t\t\t        )\n\n\t\t\t\t        IF @ColumnName IS NOT NULL\n\n\t\t\t\t        BEGIN\n\t\t\t\t            INSERT INTO #Results\n\t\t\t\t            EXEC\n\t\t\t\t            (\n\t\t\t\t                'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 150) FROM ' + @TableName + ' (NOLOCK) ' +\n\t\t\t\t                ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2\n\t\t\t\t            )\n\t\t\t\t        END\n\t\t\t\t    END\n\t\t\t\tEND\n\n\t\t\t\tSELECT ColumnName, ColumnValue FROM #Results\n\n\t\t\t\tDROP TABLE #Results\n\n\t\t\t***/}), search);\n\t\t}\n\t}\n\n\tmodule.exports = exports = Queries;\n\n} ());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/tables.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries');\n\n    class TablesCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.tables';\n            this.usage = '.tables';\n            this.description = 'Lists all the tables';\n        }\n\n        run(messages, writer) {\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.listTablesSql()));\n        }\n    }\n\n    module.exports = exports = TablesCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/sprocs.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries');\n\n    class SprocsCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.sprocs';\n            this.usage = '.sprocs';\n            this.description = 'Lists all the stored procedures';\n        }\n\n        run(messages, writer) {\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.listSprocsSql()));\n        }\n    }\n\n    module.exports = exports = SprocsCommand;\n\n} ());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/search.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries'),\n        Q = require('q');\n\n    class SearchCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.search';\n            this.usage = '.search';\n            this.description = 'Search all columns in all tables for a value';\n        }\n\n        run(messages, writer, args) {\n            if (!Utils.validateArgs(args, 1)) {\n                return Q.reject('No search value supplied');\n            }\n            messages.echo('Searching...');\n            \n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.searchSql(args[0])));\n        }\n    }\n\n    module.exports = exports = SearchCommand;\n\n} ());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/indexes.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Q = require('q'),\n        Queries = require('./queries');\n\n    class IndexesCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.indexes';\n            this.usage = '.indexes TABLE';\n            this.description = 'Lists all the indexes of a table';\n        }\n\n        run(messages, writer, args) {\n            if (!Utils.validateArgs(args, 1)) {\n                return Q.reject('Table name not specified');\n            }\n\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.listIndexesSql(args[0])));\n        }\n    }\n\n    module.exports = exports = IndexesCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/read.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Q = require('q'),\n        FileExecutor = require('./fileexecutor');\n\n    class ReadCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.read';\n            this.usage = '.read FILENAME';\n            this.description = 'Execute commands in a file';\n        }\n\n        run(messages, writer, args) {\n            if (!Utils.validateArgs(args, 1)) {\n                return Q.reject('File name not specified');\n            }\n\n            var file = args.join(' '),\n                Commands = require('./index'),\n                invoker = new Commands.Invoker(this.db, messages, writer),\n                buffer = new Commands.Buffer(),\n                executor = new FileExecutor(execute, line => buffer.addLine(line));\n\n            buffer.on('command', cmd => executor.addTask(cmd));\n\n            function execute(cmd) {\n                messages.echo(cmd);\n                return invoker.run(cmd);\n            }\n\n            return executor.start(file, ()=> buffer.flush());\n        }\n    }\n\n    module.exports = exports = ReadCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/fileexecutor.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Q = require('q');\n\n    class FileExecutor {\n        constructor(executor, parser) {\n            this.executor = executor;\n            this.parser = parser;\n        }\n\n        start(file, onClose) {\n            this.deferred = Q.defer();\n            this.reader = Utils.readFile(this.deferred, file);\n            this.last = new Q();\n\n            if (this.reader) {\n                this.reader.on('error', err => {\n                    // if we fail to read, we end the command\n                    this.deferred.reject(err);\n                });\n\n                this.reader.on('line', line => {\n                    if (this.deferred.promise.isFulfilled()) {\n                        return;\n                    }\n                    else {\n                        this.parser(line);\n                    }\n                });\n\n                this.reader.on('close', () => {\n                    onClose();\n\n                    this.last.then(() => {\n                        if (!this.deferred.promise.isFulfilled()) {\n                            this.deferred.resolve();\n                        }\n                    });\n                });\n            }\n\n            // when the promise is resolved, close the reader\n            this.deferred.promise.finally(() => {\n                this.reader.close();\n            });\n\n            return  this.deferred.promise;\n        }\n\n        addTask(task) {\n            if (!task) return;\n\n            this.reader.pause();\n\n            this.last = this.last.then(() => {\n                return this.executor(task);\n            });\n\n            this.last.then(() => {\n                if (!this.deferred.promise.isFulfilled()) {\n                    // if executes successfully then resume reading\n                    this.reader.resume();\n                }\n            });\n\n            this.last.catch((err) => {\n                if (!this.deferred.promise.isFulfilled()) {\n                    // if any statement fails, we end the command\n                    this.deferred.reject(err);\n                }\n            });\n        }\n    }\n\n    module.exports = exports = FileExecutor;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/run.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Q = require('q'),\n        FileExecutor = require('./fileexecutor');\n\n    class RunCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.run';\n            this.usage = '.run FILENAME';\n            this.description = 'Execute the file as a sql script';\n        }\n\n        run(messages, writer, args) {\n            if (!Utils.validateArgs(args, 1)) {\n                return Q.reject('File name not specified');\n            }\n\n            var file = args.join(' '),\n                Commands = require('./index'),\n                invoker = new Commands.Invoker(this.db, messages, writer),\n                executor = new FileExecutor(execute, parse),\n                buffer = '',\n                db = this.db;\n\n            function execute(script) {\n                messages.echo(script);\n                return Utils.runQuery(messages, writer, db.query.bind(db, script));\n            }\n\n            function parse (line) {\n                if (line.trim() === 'GO') {\n                    executor.addTask(buffer);\n                    buffer = '';\n                }\n                else {\n                    buffer = Utils.appendLine(buffer, line);\n                }\n            }\n\n            function onClose() {\n                executor.addTask(buffer);\n            }\n\n            return executor.start(file, onClose);\n        }\n    }\n\n    module.exports = exports = RunCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/schema.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries'),\n        Q = require('q');\n\n    class GetSchemaCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.schema';\n            this.usage = '.schema TABLE';\n            this.description = 'Shows the schema of a table';\n        }\n\n        run(messages, writer, args) {\n            if (!Utils.validateArgs(args, 1)) {\n                return Q.reject('Table name not specified');\n            }\n\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.getSchemaSql(args[0])));\n        }\n    }\n\n    module.exports = exports = GetSchemaCommand;\n\n} ());\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/analyze.js":"(function () {\n    \"use strict\";\n\n    var Utils = require('./utils'),\n        Queries = require('./queries');\n\n    class AnalyzeCommand {\n        constructor(db) {\n            this.db = db;\n            this.prefix = '.analyze';\n            this.usage = '.analyze';\n            this.description = 'Analyzes the database for missing indexes.';\n        }\n\n        run(messages, writer, args) {\n            return Utils.runQuery(messages, writer, this.db.query.bind(this.db, Queries.listMissingIndexesSql()));\n        }\n    }\n\n    module.exports = exports = AnalyzeCommand;\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/commands/quit.js":"(function () {\n    \"use strict\";\n\n    var exit = require('../../external/exit'),\n        Q = require('q');\n\n    class QuitCommand {\n        constructor() {\n            this.prefix = '.quit';\n            this.usage = '.quit';\n            this.description = 'Exit the cli';\n        }\n\n        run() {\n            exit(0);\n            return new Q();\n        }\n    }\n\n    module.exports = exports = QuitCommand;\n\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/external/exit.js":"/*\n * exit\n * https://github.com/cowboy/node-exit\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nmodule.exports = function exit(exitCode, streams) {\n  if (!streams) { streams = [process.stdout, process.stderr]; }\n  var drainCount = 0;\n  // Actually exit if all streams are drained.\n  function tryToExit() {\n    if (drainCount === streams.length) {\n      process.exit(exitCode);\n    }\n  }\n  streams.forEach(function(stream) {\n    // Count drained streams now, but monitor non-drained streams.\n    if (stream.bufferSize === 0) {\n      drainCount++;\n    } else {\n      stream.write('', 'utf-8', function() {\n        drainCount++;\n        tryToExit();\n      });\n    }\n    // Prevent further writing.\n    stream.write = function() {};\n  });\n  // If all streams were already drained, exit now.\n  tryToExit();\n  // In Windows, when run as a Node.js child process, a script utilizing\n  // this library might just exit with a 0 exit code, regardless. This code,\n  // despite the fact that it looks a bit crazy, appears to fix that.\n  process.on('exit', function() {\n    process.exit(exitCode);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/resultwriter.js":"(function () {\n    \"use strict\";\n\n    var _ = require('underscore'),\n        _str = require('underscore.string'),\n        Table = require('easy-table'),\n        csv = require('ya-csv'),\n        sprintf = require(\"sprintf-js\").sprintf;\n\n    _.mixin(_str.exports());\n\n    class ResultWriter {\n        static create(format) {\n            if (!format || format == 't' || format == 'table') {\n                return new TableWriter();\n            }\n            else if (format == 'c' || format == 'csv') {\n                return new CsvWriter();\n            }\n            else if (format == 'x' || format == 'xml') {\n                return new XmlWriter();\n            }\n            else if (format == 'j' || format == 'json') {\n                return new JsonWriter();\n            }\n            else {\n                throw new Error(sprintf(\"Format '%s' is not supported.\", format));\n            }\n        }\n\n        constructor() {\n        }\n\n        startResult() {\n            this.firstSet = true;\n        }\n\n        startSet() {\n        }\n\n        writeRows() {\n        }\n\n        endSet() {\n            this.firstSet = false;\n        }\n\n        endResult() {\n        }\n\n        formatItem(item) {\n            _.each(item, (value, key) => {\n                if (value instanceof Date) {\n                    item[key] = value.toISOString();\n                } else if (value instanceof Buffer) {\n                    item[key] = value.toString('hex');\n                }\n            });\n        }\n\n        log(output) {\n            if (output === undefined) {\n                output = '';\n            }\n            console.log(output);\n        }\n    }\n\n    class TableWriter extends ResultWriter {\n        constructor() {\n            super();\n\n            // avoid printing extra blank line after result\n            this.appendsLineToResult = true;\n\n            // can afford extra information between resultsets\n            this.freeFormat = true;\n        }\n\n        startSet() {\n            super.startSet();\n            \n            if (!this.firstSet) {\n                this.log();\n            }\n        }\n\n        writeRows(result) {\n            result.forEach(this.formatItem.bind(this));\n            this.log(Table.print(result));\n        }\n    }\n\n    class JsonWriter extends ResultWriter {\n        constructor() {\n            super();\n        }\n\n        startResult() {\n            super.startResult();\n\n            this.log('[');\n        }\n\n        startSet() {\n            super.startSet();\n\n            if (this.firstSet) {\n                this.log('[');\n            }\n            else {\n                this.log(',[');\n            }\n\n            this.firstRow = true;\n        }\n\n        writeRows(result) {\n            var prefix = this.firstRow ? '' : ',';\n            this.log(prefix + JSON.stringify(result || [], null, 4));\n        }\n\n        endSet() {\n            super.endSet();\n\n            this.log(']');\n        }\n\n        endResult() {\n            super.endResult();\n\n            this.log(']');\n        }\n    }\n\n    class XmlWriter extends ResultWriter {\n        constructor() {\n            super();\n        }\n\n        startResult() {\n            super.startResult();\n\n            this.log('<?xml version=\"1.0\"?>');\n            this.log('<results>');\n        }\n\n        startSet() {\n            super.startSet();\n\n            this.log('   <result>');\n        }\n\n        writeRows(result) {\n            result = result || [];\n            result.forEach(item => {\n                this.formatItem(item);\n\n                this.log('       <row>');\n                Object.keys(item)\n                    .forEach(key => {\n                        var value = this._escape(item[key]);\n                        key = this._escape(key);\n                        this.log(sprintf('         <%s>%s</%1$s>', key, value));\n                    });\n                this.log('       </row>');\n            });\n        }\n\n        endSet() {\n            super.endSet();\n\n            this.log('   </result>');\n        }\n\n        endResult() {\n            super.endResult();\n\n            this.log('</results>');\n        }\n\n        _escape(text) {\n            if (typeof text !== 'string') {\n                return text;\n            }\n\n            return text.replace('\"', '&quot;')\n                .replace(\"'\", '&apos;')\n                .replace('<', '&lt;')\n                .replace('>', '&gt;')\n                .replace('&', '&amp;');\n        }\n    }\n\n    class CsvWriter extends ResultWriter {\n        constructor() {\n            super();\n\n            this.writer = csv.createCsvStreamWriter(process.stdout);\n        }\n\n        startSet() {\n            super.startSet();\n            \n            if (!this.firstSet) {\n                this.log();\n            }\n            this.firstRow = true;\n        }\n\n        writeRows(result) {\n            result = result || [];\n            result.forEach((item, i) => {\n                // if it is first row then write column names\n                if (this.firstRow) {\n                    this.writer.writeRecord(_.keys(item));\n                    this.firstRow = false;\n                }\n\n                this.formatItem(item);\n\n                this.writer.writeRecord(_.values(item));\n            });\n        }\n    }\n\n    ResultWriter.XmlWriter = XmlWriter;\n    ResultWriter.JsonWriter = JsonWriter;\n    ResultWriter.TableWriter = TableWriter;\n    ResultWriter.CsvWriter = CsvWriter;\n\n    module.exports = exports = ResultWriter;\n} ());","/home/travis/build/npmtest/node-npmtest-sql-cli/node_modules/sql-cli/lib/messages.js":"(function () {\n    \"use strict\";\n\n    var _ = require('underscore'),\n        sprintf = require(\"sprintf-js\").sprintf;\n\n    class Messages {\n        constructor() {\n            this.enabled = true;\n            this.interactiveMode = true;\n        }\n\n        empty() {\n            this._log();\n        }\n\n        echo(line) {\n            if (this.interactiveMode) {\n                this._log(line);\n            }\n        }\n\n        connecting(server) {\n            if (this.interactiveMode) {\n                this._write(sprintf('Connecting to %s...', server));\n            }\n        }\n\n        connected() {\n            this._log('done');\n        }\n\n        connectionerror(err) {\n            if (this.interactiveMode) {\n                this.empty();\n            }\n            this.error(err);\n        }\n\n        welcome(version) {\n            this._log();\n            this._log('sql-cli version ' + version);\n            this._log('Enter \".help\" for usage hints.');\n        }\n\n        error(err) {\n            var message = null;\n            if (err instanceof Error && err.message) {\n                message = err.message;\n            }\n            else if (err) {\n                message = err.toString();\n            }\n            message = message || 'Unexpected error';\n\n            // we write errors even if disabled\n            console.error(sprintf('Error: %s', message));\n        }\n\n        done() {\n            this._log('OK');\n        }\n\n        rowCount(rows, skipLine) {\n            if (!skipLine) {\n                this._log();\n            }\n            this._log(sprintf('%d row(s) returned', rows));\n        }\n\n        resultsetsEnd(resultsets, elapsed) {\n            this._log();\n            this._log(sprintf('Executed in %f ms', resultsets, elapsed));\n        }\n\n        _write() {\n            if (!this.enabled) return;\n\n            process.stdout.write.apply(process.stdout, arguments);\n        }\n\n        _log() {\n            if (!this.enabled) return;\n\n            console.log.apply(null, arguments);\n        }\n    }\n\n    module.exports = exports = Messages;\n} ());"}